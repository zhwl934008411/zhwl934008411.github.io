<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Celery入门]]></title>
    <url>%2F2019%2F03%2F28%2FCelery%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Celery入门Celery基础Celery是一个专注于实时处理和任务调度的分布式任务队列。Celery特性：方便查看定时任务的执行情况(包含执行结果，执行状态，执行时间等)、任务支持后台管理(安装flower组件)、可选多进程Eventlet和Gevent三种模式执行任务、支持多种消息代理和后端存储 Celery包含的组件: Producer：任务生产者，可用task装饰器或其他方法将函数转化为celery任务 Broker:消息代理（或称消息中间件），接收Celery Beat发送过来的任务，存储到任务队列再有序发给worker执行，生产环境推荐使用Rabbit或Redis存储任务队列 Celery Beat:任务调度器，负责发布异步或定时任务给Broker Celery Workr:任务执行者， Result Backend:任务处理完保存执行状态和结果，生产环境推荐使用redis存储当worker运行完结果之后就会把他返回给生产者的唯一id作为键，将结果作为值传递给你设置的worker(backend测试环境为redis). Celery序列化:在Broker和消费者之间传输的是序列化的数据（类似前后端分离传递json），支持pickle/json/yaml/msgpack方案，推荐使用msgpack Celery的使用1.安装pip install celeryredispip install redis==2.10.6 msgpack celery==3.1.20(windows采用方案) 2.采用celery包启动 准备：新建python包celery_learn、app.py文件celery_learn 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# __init__.pyfrom celery import Celeryapp = Celery("mytask")app.config_from_object('celery_learn.celery_config')# celery_config.py# -*- coding: utf-8 -*-from datetime import timedeltafrom celery.schedules import crontabBROKER_URL = "redis://127.0.0.1:6379/4"BACKEND_URL = "redis://127.0.0.1:6379/5"# CELERY_RESULT_BACKEND = "redis://127.0.0.1:6379/5"CELERY_TIMEZONE = 'Asia/Shanghai'# 导入指定的任务模块CELERY_IMPORTS = ( 'celery_learn.task1', 'celery_learn.task2',)# 定时任务CELERYBEAT_SCHEDULE = &#123; 'task1': &#123; 'task': 'celery_learn.task1.func', 'schedule': timedelta(seconds=10), # 'args': () &#125;, 'task2': &#123; 'task': 'celery_learn.task2.add', 'schedule': crontab(hour=11, minute=48), 'args': (4, 5) &#125;&#125;# task1.pyfrom celery_learn import app@app.taskdef func(list1=None): if list1 is None: list1 = [] for i in range(10000000): list1.append(i) return list1[-1]# task2.pyimport timefrom celery_learn import app@app.taskdef add(x,y): time.sleep(3) return x+y app.py1234567891011from celery_learn import task1from celery_learn import task2if __name__ == '__main__': task1.func.delay() # 或者用apply_async() # task1.func.apply_async() task2.add.delay(2,3) print("end.....") 3.启动 -A参数：指定任务启动的文件名 -l参数：指定日志级别(INFO,DEBUG,WARNING,ERROR,默认是WARNING)1.开启异步任务 启动worker：celery worker -A celery_learn -l INFO 开启任务:python app.py2.开启定时任务 celery任务调度Beat(用作定时任务)：celery beat -A celery_learn -l INFO 启动worker：celery worker -A celery_learn -l INFO –logfile celery_learn/log/celery.log 一起启动beat和worker：celery -B -A celery_learn worker -l INFO(windows不适用)https://github.com/zhwl934008411/celery-learning]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Celery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用socket和线程池爬取数据]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BD%BF%E7%94%A8socket%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[使用socket和线程池爬取数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 使用socket和线程池爬取数据import socketfrom urllib.parse import urlparsedef get_url(url): #通过socket请求html url = urlparse(url) host = url.netloc# 提取主域名 path = url.path if path == "": path = "/" #建立socket连接 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # client.setblocking(False) client.connect((host, 80)) #阻塞不会消耗cpu #不停的询问连接是否建立好， 需要while循环不停的去检查状态 #做计算任务或者再次发起其他的连接请求 client.send("GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n".format(path, host).encode("utf8")) data = b"" while True: d = client.recv(1024) if d: data += d else: break data = data.decode("utf8") html_data = data.split("\r\n\r\n")[1]# 去掉HTTP请求头 # print(data) print(html_data) client.close()if __name__ == "__main__": import time start_time = time.time() # pip install threadpool import threadpool pool = threadpool.ThreadPool(10) urllist = [] for i in range(2,20): url = "xxx/?page=&#123;&#125;/".format(i) urllist.append(url) requests = threadpool.makeRequests(get_url,urllist) [pool.putRequest(req) for req in requests] pool.wait() # for url in range(2,5): # url = "xxx/?page=&#123;&#125;/".format(url) # get_url(url) print(time.time()-start_time)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程与队列的运用]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[多线程与队列的运用（多进程，进程池，协程池）多线程和队列、多进程和队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 多线程from queue import Queuefrom threading import Threadimport timequeue = Queue()def put_data(): for i in range(100): print("添加数据: &#123;&#125;".format(i)) queue.put_nowait(i)def get_data(): time.sleep(0.01) while True: print("获取数据:&#123;&#125;".format(queue.get())) queue.task_done()# 创建线程执行任务t1 = Thread(target=put_data)t1.setDaemon(True)t1.start()t2 = Thread(target=get_data)# 把当前线程设置为守护线程t2.setDaemon(True)t2.start()# 让主线线程等待队列的任务完成queue.join()print('主线程结束了')"""改为多进程：from queue import Queuefrom threading import Thread修改为from multiprocessing import JoinableQueuefrom multiprocessing import Process"""# 补充:多进程任务添加参数，from multiprocessing import Manager，JoinableQueue，Processqueue = JoinableQueue()def put_data(): for i in range(100): print("添加数据: &#123;&#125;".format(i)) queue.put_nowait(i)def get_data(l): time.sleep(0.01) while True: print("获取数据:&#123;&#125;".format(queue.get())) l.append(i) queue.task_done()with Manager() as manager: L = manager.list() p_obj = [] for i in range(30): p = Process(target=get_data, args=(L,)) p.start() p_obj.append(p) for p in p_obj: p.join() list1 = list(L) 进程池和队列12345678910111213141516171819202122232425262728293031323334353637383940"""改为进程池：from queue import Queuefrom threading import Thread修改为from multiprocessing.dummy import Poolfrom queue import Queue"""from multiprocessing.dummy import Poolfrom queue import Queueimport timequeue = Queue()def put_data(): for i in range(100): print("添加数据: &#123;&#125;".format(i)) queue.put_nowait(i)def get_data(): while True: print("获取数据:&#123;&#125;".format(queue.get())) time.sleep(0.01) queue.task_done()# 创建进程池对象pool = Pool(3)# 执行异步任务pool.apply_async(put_data)pool.apply_async(get_data)# pool.close()# 让主进程等待 进程池中任务完成# pool.join()# 让主进程稍微等待下time.sleep(0.1)# 等待队列任务的完成queue.join() 协程池和队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 打猴子补丁from gevent import monkeymonkey.patch_all()# 导入协程池from gevent.pool import Pool"""总结: 线程池改协程池1. 把导入进程池, 改为导入协程池2. 打猴子补丁3. 初始化方法, 创建协程池可以不指定个数"""from queue import Queueimport timequeue = Queue()def put_data(): for i in range(100): print("添加数据: &#123;&#125;".format(i)) queue.put_nowait(i)def get_data(): while True: print("获取数据:&#123;&#125;".format(queue.get())) time.sleep(0.01) queue.task_done()# 创建协程池对象pool = Pool()# 执行异步任务pool.apply_async(put_data)pool.apply_async(get_data)# pool.close()# 让主线程等待 协程池中任务完成# pool.join()# 让主线程稍微等待下time.sleep(0.1)# 等待队列任务的完成queue.join() 待完成：supervisor使用.md]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用socket和asynico库爬取数据]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BD%BF%E7%94%A8socket%E5%92%8Casynico%E5%BA%93%E7%88%AC%E5%8F%96%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[### 使用socket和asynico库爬取数据1234567891011121314151617181920212223242526272829303132333435363738# 使用socket和asynico库爬取数据#asyncio 没有提供http协议的接口 aiohttpimport asyncioimport socketfrom urllib.parse import urlparseasync def get_url(url): #通过socket请求html url = urlparse(url) host = url.netloc path = url.path if path == "": path = "/" #建立socket连接 reader, writer = await asyncio.open_connection(host,80) writer.write("GET &#123;&#125; HTTP/1.1\r\nHost:&#123;&#125;\r\nConnection:close\r\n\r\n".format(path, host).encode("utf8")) all_lines = [] async for raw_line in reader: data = raw_line.decode("utf8") all_lines.append(data) html = "\n".join(all_lines) html_data = html.split("\r\n\r\n") print(len(html_data)) return html_dataasync def main(): url = "xxx/?page=&#123;&#125;" for i in range(2,20): task = asyncio.create_task(get_url(url.format(i))) await taskif __name__ == "__main__": import time start_time = time.time() asyncio.run(main(),debug=True) print('last time:&#123;&#125;'.format(time.time()-start_time)) https://docs.python.org/zh-cn/3/library/asyncio.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>asynico</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket通信实现]]></title>
    <url>%2F2019%2F03%2F28%2Fsocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[socket通信实现使用多线程搞定多客户端连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 使用多线程搞定多客户端连接# socket_client.pyimport socketclient = socket.socket(socket.AF_INET,socket.SOCK_STREAM)client.connect(("127.0.0.1",8888))while True: str1 = input() client.send(str1.encode("utf8")) if str1== "exit" or str1== "bye": break data = client.recv(1024) print(data.decode("utf8")) # client.close()client.close()# socket_server.pyimport socketfrom threading import Thread# SOCK_STREAM： TCP传输协议，可靠，有序传输 SOCK_DGRAM UDPserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind(('127.0.0.1', 8888))server.listen()# 使用多线程搞定多客户端连接def handle_socket(sock, addr): while True: # 一次获取1kb的数据 data = sock.recv(1024) print(data.decode("utf-8")) if data.decode("utf-8") == "exit" or data.decode("utf-8") == "bye": break str1 = input() sock.send(str1.encode("utf-8")) server.close() sock.close()while True: sock, addr = server.accept() # 使用多线程处理客户端连接 sockthread = Thread(target=handle_socket, args=(sock, addr)) sockthread.start() # server.close() # sock.close() 单客户端连接123456789101112131415161718192021222324252627282930313233343536# 单客户端连接# socket_server.pyimport socketfrom threading import Thread# SOCK_STREAM： TCP传输协议，可靠，有序传输 SOCK_DGRAM UDPserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server.bind(('127.0.0.1', 8888))server.listen()sock, addr = server.accept()while True: # 一次获取1kb的数据 data = sock.recv(1024) print(data.decode("utf-8")) if data.decode("utf-8") == "exit" or data.decode("utf-8") == "bye": break str1 = input() sock.send(str1.encode("utf-8"))server.close()sock.close()# socket_client.pyimport socketclient = socket.socket(socket.AF_INET,socket.SOCK_STREAM)client.connect(("127.0.0.1",8888))while True: str1 = input() client.send(str1.encode("utf8")) data = client.recv(1024) print(data.decode("utf8"))client.close()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python上下文管理类型]]></title>
    <url>%2F2019%2F03%2F28%2Fpython%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Python上下文管理类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 上下文管理协议（常用于文件自动关闭、线程锁自动释放、数据库自动关闭连接、socket连接）# 最简单的实现class Sample(object): def __enter__(self): print("enter") return self def __exit__(self, exc_type, exc_val, exc_tb): print("exit") def do_something(self): print("do something")# with语句首先先调用__enter__方法with Sample() as sample: # 方法执行结束后自动调用__exit__方法 sample.do_something()# 线程锁自动释放的实现import threadingclass LockContext(object): def __init__(self): self.lock = threading.Lock() def __enter__(self): print("enter") self.lock.acquire() return self def __exit__(self, exc_type, exc_val, exc_tb): print("exit") self.lock.release()my_list=[1,2,3]with LockContext():my_list.append(4)# 附加：# 文件自动关闭、线程锁自动释放、数据库自动关闭连接，socket自动关闭连接with open("a.txt",'w') as file: file.write("hello world")import threadinglock = threading.Lock()my_list=[1,2,3]with lock: my_list.append(4)import sqlite3sql_conn = sqlite3.connect("result.db", timeout=5)with sql_conn as cur: cur.execute("SELECT * FROM xxx")import socketwith socket.socket(socket.AF_INET,socket.SOCK_STREAM) as client: client.connect("127.0.0.1",8000) client.send("hello".encode("utf8"))# 使用上下文管理工具contextlib，不用再创建类以及实现__enter__,__exit__方法from contextlib import contextmanager@contextmanagerdef make_conn_context(sqlpath): import sqlite3 sql_conn = sqlite3.connect(sqlpath, timeout=5) try: yield sql_conn finally: sql_conn.close()with make_conn_context(sqlpath="result.db") as cur: create_sql = '''create table requisitioninfo( ip_address varchar(20) not null, master varchar(50) not null); ''' cur.execute(create_sql) Python常用的魔术方法作用：增强类的功能,定义后不需要显式调用,主要分为以下几类 字符串表示：__str__,__repr__ 集合,序列相关，__len__,__getitem__,__setitem__,__delitem__,__contains__ 迭代相关：__iter__,__next__ 可调用:__call__ with上下文管理器:__enter__,__exit__ 数值转换：__abs__,__bool__,__int__,__float__,__hash__,__index__ 元类相关:__new__,__init__ 属性相关：__getattr(self, name)__,__setattr(self, name, value)__,__getattribute__,__setattribute__,__dir__,__dict__ 属性描述符：__get__,__set__,__delete__ 数学二元运算符:__lt__,__le__,__eq__,__ne__,__gt_,__ge__, 1.字符串表示12345678910111213141516171819# 字符串表示"""打印实例，返回我们想要的结果，可以添加__repr__,__str__方法打印列表以及字典等容器类型或命令行查看实例会调用: __repr__ 方法,"""class MyClass(object): def __init__(self,str1): self.str1 = str1 def __str__(self): return "__str__:&#123;&#125;".format(self.str1) def __repr__(self): return "__repr__:&#123;&#125;".format(self.str1)if __name__ == '__main__': str1 = "示例字符串" mc = MyClass(str1) print(mc) 2.集合,序列相关，迭代相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-# 自定义listclass FunctionalList(object): ''' 实现了内置类型list的功能,并丰富了一些其他方法: head, tail, init, last, drop, take''' def __init__(self, values=None): if values is None: self.values = [] else: self.values = values def __len__(self):# 返回长度 return len(self.values) def __getitem__(self, key):# 返回list某个索引的值 return self.values[key] def __setitem__(self, key, value): self.values[key] = value def __delitem__(self, key): del self.values[key] def __contains__(self, item): if item in self.values: return True return False def __iter__(self): return iter(self.values) def __reversed__(self): return FunctionalList(reversed(self.values)) def append(self, value): self.values.append(value) def head(self): # 获取第一个元素 return self.values[0] def tail(self): # 获取第一个元素之后的所有元素 return self.values[1:] def init(self): # 获取最后一个元素之前的所有元素 return self.values[:-1] def last(self): # 获取最后一个元素 return self.values[-1] def drop(self, n): # 获取所有元素，除了前N个 return self.values[n:] def take(self, n): # 获取前N个元素 return self.values[:n]if __name__ == '__main__': fl = FunctionalList(values=[1,2,3,4,5]) print(1 in fl) print(len(fl)) for i in reversed(fl): print(i) print(fl.head()) print(fl.tail()) print(fl.init()) print(fl.last()) print(fl.drop(1)) print(fl.take(1)) fl.append(6) for i in fl: print(i) 3.属性相关123456789101112131415161718# 正确用法def __setattr__(self, name, value): self.__dict__[name] = value # 给类中的属性名分配值def __getattr__(self, name): return self.__dict__[name]"""附加说明__getattribute__与__getattr__的区别__getattribute__定义了你的属性被访问时的行为，相比较，__getattr__只有该属性不存在时才会起作用。因此，在支持__getattribute__的Python版本,调用__getattr__前必定会调用 __getattribute__。__getattribute__同样要避免”无限递归”的错误。需要提醒的是，最好不要尝试去实现__getattribute__,因为很少见到这种做法，而且很容易出bug。""" 4.属性描述符12345678910111213141516171819202122232425262728293031323334'''使用描述符来实现需要类型检查的属性:分别实现__get__,__set__,__delete__方法,在__set__内使用isinstance函数做类型检查'''class Attr(object): def __init__(self, name, type_): self.name = name self.type_ = type_ def __get__(self, instance, cls): # print('in __get__', instance, cls) return instance.__dict__[self.name] def __set__(self, instance, value): print('in __set__') if not isinstance(value,self.type_): raise TypeError('expected an %s' % self.type_) instance.__dict__[self.name] = value def __delete__(self, instance): # print('in __del__') del instance.__dict__[self.name]class Person(object): # x = Descriptor() # x为类的属性 name = Attr('name', str) age = Attr('age', int) heigth = Attr('height', float)p = Person()p.name = 'Bob'print(p.name) 5.数学二元运算符，描述符12345678910111213141516171819202122232425262728293031323334353637383940414243444546# coding:utf8from functools import total_orderingfrom math import pifrom abc import ABCMeta, abstractmethod@total_ordering # 装饰器class Shape(object): @abstractmethod def getArea(self): pass def __lt__(self, obj): print('in__lt__') if not isinstance(obj, Shape): raise TypeError('obj is not Shape') return self.getArea() &lt; obj.getArea() def __eq__(self, obj): print('in__eq__') if not isinstance(obj, Shape): raise TypeError('obj is not Shape') return self.getArea() == obj.getArea()class Circle(Shape): def __init__(self, radius): self.radius = radius def getRadius(self): # return self.radius return round(self.radius, 2) # 表示四舍五入后保留小数点后两位 def setRadius(self, value): if not isinstance(value, (int, long, float)): raise valueError('wrong type .') self.radius = float(value) def getArea(self): return self.radius * self.radius * pi R = property(getRadius, setRadius)radius1 = Circle(4)radius2 = Circle(5)print(radius1 == radius2)print(radius1 &lt; radius2)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django性能分析]]></title>
    <url>%2F2019%2F03%2F27%2Fdjango%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[django-debug-toolbardjango-debug-toolbar是非常好用的django性能分析工具安装:pip install django-debug-toolbar123456789101112# settings.py增加如下内容INSTALLED_APPS.append('djcelery',)MIDDLEWARE.append('debug_toolbar.middleware.DebugToolbarMiddleware',)INTERNAL_IPS = ['127.0.0.1']# urls.pyif settings.DEBUG: import debug_toolbar urlpatterns += [ path(r'__debug__/', include(debug_toolbar.urls)), ]]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django集成celery添加异步任务]]></title>
    <url>%2F2019%2F03%2F27%2Fdjango%E9%9B%86%E6%88%90celery%E6%B7%BB%E5%8A%A0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[django集成celery添加异步任务django集成celery一.安装pip install celery[redis](windows不适用,4.1.0版本定时任务有bug) pip install redis==2.10.6 msgpack celery==3.1.20(windows采用方案) pip install django-celery-3.2.2 二.应用1.添加celery配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# settings.py增加如下内容INSTALLED_APPS.append('djcelery',)from .celeryconfig import *BROKER_BACKEND = 'redis'BROKER_URL = 'redis://@127.0.0.1:6379/1'CELERY_RESULT_BACKEND = 'redis://@127.0.0.1:6379/2'# settings同一目录下添加celeryconfig.py# celeryconfig.pyfrom datetime import timedeltaimport djceleryfrom celery.schedules import crontabdjcelery.setup_loader()CELERY_IMPORTS = ( 'app.tasks',)CELERY_TASK_SERIALIZER = "msgpack"CELERY_RESULT_SERIALIZER = "json"CELERY_TASK_RESULT_EXPIRES = 60 * 60 * 24 # 任务执行结果超时时间CELERY_ACCEPT_CONTENT = ['json','msgpack']CELERY_TIMEZONE = 'Asia/Shanghai'# 有些情况可以防止死锁CELERY_FORCE_EXECV =True# 设置并发的worker数CELERY_CONCURRENCY = 4# 允许重试CELERY_ACKS_LATE = True# 每个worker最多执行100个任务被销毁，可以防止内存泄漏CELERY_MAX_TASKS_PER_CHILD = 100# 单个任务运行超时时间CELERY_TASK_TIME_LIMIT = 12 * 30# 自定义任务队列CELERY_QUEUES = &#123; # 定时任务队列 'beat_task':&#123; 'exchange':'beat_task', 'exchange_type':'direct', 'binding_key':'beat_task' &#125;, # 普通异步任务队列 'work_queue':&#123; 'exchange':'work_queue', 'exchange_type':'direct', 'binding_key':'work_queue' &#125;,&#125;CELERY_DEFAULT_QUEUE = 'work_queue'# 定时任务CELERYBEAT_SCHEDULE = &#123; 'task1':&#123; 'task':'mytask', 'schedule':timedelta(seconds=10),# 每十秒执行一次 'args':(), 'options':&#123; 'queue':'beat_task' &#125; &#125;, 'task2': &#123; 'task': 'mytask2', 'schedule': crontab(hour=17,minute=51), #16:50执行 'options':&#123; 'queue':'beat_task' &#125; &#125;&#125; 2.添加任务1234567891011121314151617181920212223242526272829303132333435363738394041424344# 运行python manage.py startapp app,app目录下添加tasks.py# tasks.pyfrom celery.task import Task# 定时任务class MyTask(Task): name = "mytask" def run(self,list1=None): if list1 is None: list1 = [] for i in range(10000000): list1.append(i) return list1[-1]# 异步任务class MyTask2(Task): name = "mytask2" def run(self,list1=None): if list1 is None: list1 = [] for i in range(10000000): list1.append(i) return list1[-1]# view.pyfrom django.http.response import JsonResponsefrom django.shortcuts import renderfrom .tasks import MyTask2# Create your views here.def do(request): # CourseTask.delay() # 执行异步任务 print('do request') MyTask2.apply_async(args=([1,2,3],),queue="work_queue") return JsonResponse(&#123;'result': 'ok'&#125;)# urls.pyfrom app.views import dourlpatterns.append(path('run/',do,name="run")) 三.启动-l参数：指定日志级别(INFO,DEBUG,WARNING,ERROR,默认是WARNING) 1.开启异步任务1.启动worker：python manage.py celery worker -l INFO --logfile /log/celery.log 2.启动django：python manage.py runserver 3.访问URL:127.0.0.1:8000/run 2.再开启定时任务celery任务调度Beat：python manage.py celerybeat -l info --logfile /log/beat.log 四.任务监控 flower安装：pip install flower启动：celery flower –basic_auth=root:123456访问：127.0.0.1:5555 https://github.com/zhwl934008411/celery-learning]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django http请求处理流程]]></title>
    <url>%2F2019%2F03%2F26%2Fdjango-http%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[django http请求处理流程：1. 加载setting.py 2. 创建WSGIServer 3. 处理Request 1.用户通过浏览器请求一个页面 2.请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求 3.URLConf通过urls.py文件和请求的URL找到相应的View 4.View Middlewares被访问，它同样可以对request做一些处理或者直接返回response 5.调用View中的函数 6.View中的方法可以选择性的通过Models访问底层的数据 7.所有的Model-to-DB的交互都是通过manager完成的 8.如果需要，Views可以使用一个特殊的Context 9.Context被传给Template用来生成页面 a.Template使用Filters和Tags去渲染输出 b.输出被返回到View c.HTTPResponse被发送到Response Middlewares d.任何Response Middlewares都可以丰富response或者返回一个完全不同的response e.Response返回到浏览器，呈现给用户 4. 返回Response]]></content>
  </entry>
  <entry>
    <title><![CDATA[xadmin提供的功能列表]]></title>
    <url>%2F2019%2F03%2F26%2Fxadmin%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[xadmin提供的功能列表1.xadmin提供的基础功能1.支持无缝替换Django自带的admin 数据显示：list_display、exclude = (&apos;recommend&apos;,)、show_detail_fields、list_per_page、 list_editable #设置哪些字段可以在表页面快速编辑 过滤器和搜索字段：list_filter、search_fields、 表图标：model_icon = &apos;fa fa-list&apos; 排序：ordering = (&apos;-publish_time&apos;,)#ordering设置默认排序字段，负号表示降序排序 #设置哪些字段可以点击进入编辑界面 list_display_links = (&apos;id&apos;, &apos;caption&apos;) 2.model_icon = &apos;fa fa-list&apos; 3.refresh_times = [] # 自动刷新功能，单位是秒 2.自定义Form表单提交12345678910111213141516171819class MemberForm(forms.ModelForm): # def __init__(self): name1 = forms.RegexField( regex='^[0-9A-Za-z]&#123;3,12&#125;$', min_length=3, max_length=12, required=True, help_text='请输入域账号', label="用户1", # style=&#123;'input_type': 'password'&#125;, error_messages=&#123;'required': '域账号不能为空.', 'invalid': '域账号有且只包含数字，字母', 'min_length': '域账号长度不能小于3个字符', 'max_length': '域账号长度不能大于12个字符', &#125; )class MemberAdmin(object): list_display = ["name1", "group"] form = MemberForm 3.通过当前登录的用户过滤显示的数据123456789101112131415161718192021# get_queryset@xadmin.register(Environment)class EnvironmentAdmin(object): def get_list_queryset(self): request = self.request """函数作用：使当前登录用户只能看到添加人是自己的数据""" qs = super(EnvironmentAdmin, self).get_queryset(request) qs = super().get_queryset() if request.user.is_superuser: return qs return qs.filter(user=Environment.objects.filter(proposer=request.user))# get_readonly_fields@xadmin.register(Environment)class EnvironmentAdmin(object): readonly_fields = [ 'green_status', 'yellow_status'] def get_readonly_fields(self, request, obj=None): """ 重新定义此函数，限制普通用户所能修改的字段 """ if request.user.is_superuser: self.readonly_fields = [] return self.readonly_fields 4.数据保存时进行一些额外的操作123456789@xadmin.register(Environment)class EnvironmentAdmin(object): def save_models(self): """ 重新定义此函数，提交时自动添加申请人 """ obj = self.new_obj # obj.location.user request = self.request obj.proposer = str(request.user.username) super(EnvironmentAdmin, self).save_models() 5.页面组装，一对多字段，编辑父表同时编辑子表12345678910111213@xadmin.register(Group)class MyGroupAdmin(object): search_fields = ('name',) ordering = ('name',) style_fields = &#123;'permissions': 'm2m_transfer'&#125; model_icon = 'fa fa-group' class MemberInline(object): model = Member extra = 1 #默认显示的条目数 style = "accordion"# \xadmin\plugins\inline.py inlines = [MemberInline] 6.主题和全局设置12345678910111213141516171819202122232425262728293031# 主题功能import xadminfrom xadmin import views@xadmin.register(views.BaseAdminView)class BaseSetting(object): enable_themes = True use_booswatch = True# 全局设置@xadmin.register(views.CommAdminView)class GlobalSetting(object): site_title = "xxx" site_footer = "xxx" menu_style = "accordion" global_add_models=[] global_search_models =[]# 首页设置@xadmin.sites.register(views.website.IndexView)class MainDashboard(object): widgets = [ [ &#123;"type": "html", "title": "网络状态统计", "content": "&lt;div id='page'&gt;&lt;/div&gt;&lt;script&gt;$('#page').load('http://xxx/chart/');&lt;/script&gt;"&#125;, &#123;"type": "list", "model": "environments.Environment", "params": &#123;"o": "-add_time"&#125;&#125;, ], [ &#123;"type": "qbutton", "title": "Quick Start", "btns": [&#123;"model": Environment&#125;, &#123;"title": "发送告警邮件", "url": "http://xxx/sendEmail/"&#125;]&#125;, &#123;"type": "addform", "model": Environment&#125;, ] ]]]></content>
      <categories>
        <category>xadmin</category>
      </categories>
      <tags>
        <tag>xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django信号量入门]]></title>
    <url>%2F2019%2F03%2F26%2Fdjango%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[django信号量注册成功用户后自动创建token1234567891011121314151617181920212223242526272829303132# Signals.pyfrom django.db.models.signals import post_savefrom django.db.models.signals import post_delete # 也可以自动删除from django.dispatch import receiverfrom rest_framework.authtoken.models import Tokenfrom django.contrib.auth import get_user_modelUser = get_user_model()@receiver(post_save, sender=User)def create_auth_token(sender, instance=None, created=False, **kwargs): if created: Token.objects.create(user=instance)# djangorestframework从前端拿到用户名和密码后存储加密后的密码@receiver(post_save, sender=User)def create_user(sender, instance=None, created=False, **kwargs): if created: password = instance.password instance.set_password(password) instance.save()# app.pyfrom django.apps import AppConfigclass UsersConfig(AppConfig): name = 'users' verbose_name = "用户" def ready(self): import users.Signals]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket实现简单的HTTP服务器]]></title>
    <url>%2F2019%2F03%2F26%2Fsocket%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[socket实现简单的HTTP服务器1234567891011121314151617181920212223242526272829303132333435363738import socketEOL1 = b'\n\n'EOL2 = b'\n\r\n'body = '''Hello World!&lt;h1&gt;from the5fire&lt;/h1&gt;'''response_params = [ 'HTTP/1.0 200 OK', 'Date:Sun,27 may 2018 01:01:01 GMT', 'Content-Type:text/html;charset=utf-8', 'Content-Length:&#123;&#125;\r\n'.format(len(body.encode())), body]response = '\r\n'.join(response_params)def handle_connection(conn,addr): request = b"" while EOL1 not in request and EOL2 not in request: request += conn.recv(1024) print(request) conn.send(response.encode()) # response转为bytes再传输 conn.close()# socket1 = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) ipv4def main(): serversocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM) serversocket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) serversocket.bind(("127.0.0.1",8000)) serversocket.listen(5) print("http://127.0.0.1:8000/") try: while True: conn,address = serversocket.accept() handle_connection(conn,address) finally: serversocket.close()if __name__ == '__main__': Python 中的 Socket 编程（指南）http://python.jobbole.com/89290/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django添加login required装饰器]]></title>
    <url>%2F2019%2F03%2F26%2Fdjango%E6%B7%BB%E5%8A%A0login-required%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[django添加login required装饰器1234567891011121314from django.contrib.auth.decorators import login_requiredfrom django.utils.decorators import method_decoratorclass LoginRequiredMixin(object): @method_decorator(login_required(login_url='/login/')) def dispatch(self,request,*args,**kwargs): return super(LoginRequiredMixin,self).dispatch(request,*args,**kwargs)# 用户个人中心信息页面class UserInfoView(LoginRequiredMixin, View): def get(self, request): return render(request, "usercenter-info.html", &#123; &#125;)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xadmin自定义菜单]]></title>
    <url>%2F2019%2F03%2F26%2Fxadmin%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[xadmin自定义菜单xadmin配置自定义菜单，全局搜索字段设置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import xadminfrom django.contrib.auth.models import Group, Permission# from rest_framework.authtoken.models import Tokenfrom .models import VerifyCodefrom django.contrib.auth import get_user_modelUser = get_user_model()class GlobalSettings(object): global_search_models = [Goods, GoodsCategory] global_models_icon = &#123; Goods: &quot;fa fa-gift&quot;, GoodsCategory: &quot;fa fa-bars&quot; &#125; # menu_style = &quot;accordion&quot; def get_site_menu(self): return [ &#123; &apos;title&apos;: &apos;用户和用户操作&apos;,#菜单名称 # &apos;perm&apos;: self.get_model_perm(UserProfile, &apos;view&apos;), # &apos;icon&apos;: &apos;fa fa-bar-chart-o&apos;, &apos;menus&apos;: ( &#123; &apos;title&apos;: &apos;用户信息&apos;,#表名称 &apos;url&apos;: self.get_model_url(User, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(User, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-user&apos; &#125;, &#123; &apos;title&apos;: &apos;短信验证码&apos;, &apos;url&apos;: self.get_model_url(VerifyCode, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(VerifyCode, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-commenting&apos; &#125;, &#123; &apos;title&apos;: &apos;用户收藏&apos;, &apos;url&apos;: self.get_model_url(UserFav, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(UserFav, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-heart&apos; &#125;, &#123; &apos;title&apos;: &apos;用户留言&apos;, &apos;url&apos;: self.get_model_url(UserLeavingMessage, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(UserLeavingMessage, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-commenting-o&apos; &#125;, &#123; &apos;title&apos;: &apos;收货地址&apos;, &apos;url&apos;: self.get_model_url(UserAddress, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(UserAddress, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-address-card&apos; &#125;, &#123; &apos;title&apos;: &apos;日志记录&apos;, &apos;url&apos;: self.get_model_url(Log, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(Log, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-bars&apos; &#125;, ) &#125;, &#123; &apos;title&apos;: &apos;认证与授权&apos;, # &apos;perm&apos;: self.get_model_perm(UserProfile, &apos;view&apos;), # &apos;icon&apos;: &apos;fa fa-bar-chart-o&apos;, &apos;menus&apos;: ( # &#123; # &apos;title&apos;: &apos;令牌&apos;, # # 写死的url进行替换 # &apos;url&apos;: self.get_model_url(Token, &quot;changelist&quot;), # &apos;perm&apos;: self.get_model_perm(Token, &apos;view&apos;), # &apos;icon&apos;: &apos;fa fa-key&apos; # &#125;, &#123; &apos;title&apos;: &apos;权限&apos;, # 写死的url进行替换 &apos;url&apos;: self.get_model_url(Permission, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(Permission, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-magic&apos; &#125;, &#123; &apos;title&apos;: &apos;组&apos;, # 写死的url进行替换 &apos;url&apos;: self.get_model_url(Group, &quot;changelist&quot;), &apos;perm&apos;: self.get_model_perm(Group, &apos;view&apos;), &apos;icon&apos;: &apos;fa fa-group&apos; &#125;, ) &#125;, ]]]></content>
      <categories>
        <category>xadmin</category>
      </categories>
      <tags>
        <tag>xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xadmin与自带admin的几个接口上的差异]]></title>
    <url>%2F2019%2F03%2F26%2Fxadmin%E4%B8%8E%E8%87%AA%E5%B8%A6admin%E7%9A%84%E5%87%A0%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[xadmin与自带admin的几个接口上的差异1.get_queryset123456789# admin.py@admin.register(Environment)class EnvironmentAdmin(object): def get_queryset(self, request): """函数作用：使当前登录用户只能看到添加人是自己的数据""" qs = super(EnvironmentAdmin, self).get_queryset(request) if request.user.is_superuser: return qs return qs.filter(user=Environment.objects.filter(proposer=request.user)) 1234567891011# adminx.py@xadmin.register(Environment)class EnvironmentAdmin(object): def get_list_queryset(self): request = self.request """函数作用：使当前登录用户只能看到添加人是自己的数据""" qs = super().get_list_queryset() if request.user.is_superuser: return qs return qs.filter(user=Environment.objects.filter(proposer=request.user)) 2.save_models数据保存时进行一些额外的操作12345678# admin.py@admin.register(Environment)class EnvironmentAdmin(object): def save_model(self, request, obj, form, change): """ 重新定义此函数，提交时自动添加申请人 """ obj.proposer = str(request.user.username) super(EnvironmentAdmin, self).save_models(request, obj, form, change) 12345678910# adminx.py@xadmin.register(Environment)class EnvironmentAdmin(object): def save_models(self): """ 重新定义此函数，提交时自动添加申请人 """ obj = self.new_obj # obj.location.user request = self.request obj.proposer = str(request.user.username) super(EnvironmentAdmin, self).save_models() 3.处理inline12345678910111213# admin.py@admin.register(Group)class MyGroupAdmin(object): search_fields = ('name',) ordering = ('name',) style_fields = &#123;'permissions': 'm2m_transfer'&#125; model_icon = 'fa fa-group' class MemberInline(admin.TabularInline): model = Member extra = 1#默认显示的条目数 inlines = [MemberInline] 1234567891011121314# adminx.py@xadmin.register(Group)class MyGroupAdmin(object): search_fields = ('name',) ordering = ('name',) style_fields = &#123;'permissions': 'm2m_transfer'&#125; model_icon = 'fa fa-group' class MemberInline(object): model = Member extra = 1 style = "accordion"# \xadmin\plugins\inline.py inlines = [MemberInline]]]></content>
      <categories>
        <category>xadmin</category>
      </categories>
      <tags>
        <tag>xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django添加用户手机号认证登录]]></title>
    <url>%2F2019%2F03%2F26%2Fdjango%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E6%89%8B%E6%9C%BA%E5%8F%B7%E8%AE%A4%E8%AF%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[django添加用户手机号认证登录12345678910111213141516171819view.pyfrom django.contrib.auth.backends import ModelBackendfrom django.db.models import Qfrom django.contrib.auth import get_user_modelUser = get_user_model()class CustomBackend(ModelBackend): def authenticate(self, username=None, password=None, **kwargs): try: # 不希望用户存在两个，get只能有一个。两个是get失败的一种原因 Q为使用并集查询 # 并集查询 user = User.objects.get(Q(username=username) | Q(mobile=username)) if user.check_password(password): return user except Exception as e: return Nonesettings.pyAUTHENTICATION_BACKENDS = ( # 自定义用户验证 'users.views.CustomBackend',)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编码规范]]></title>
    <url>%2F2019%2F03%2F26%2FPython%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Python编码规范注：此为团队使用的一些规则，非通用规范，通用参考PEP8(2. https://www.python.org/dev/peps/pep-0008/#source-file-encoding) 排版 程序块使用缩进风格编写，缩进数为四个空格，不要使用Tab import语句： 1.每一个模块分行书写 2.三组库的顺序：官方库或模块+pypi上的第三库或模块+本地项目的库或模块,每组库之间加上空格 3.导入库尽量采用绝对路径引用，避免使用from xxx import * 4.django项目同一App内使用显式相对路径导入，django库放在第三方库前面 5.django view视图采用class_based_view风格写，不用函数 （https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/） 类与类，类与函数，方法与方法之间加上一行空行， 两个以上的关键字、变量、常量进行对等或运算操作时，操作符前后加上空格(函数默认参数,”*”,”**”除外) 注释 模块注释信息写在最前面 类和函数的注释信息写在定义语句的下一行，前后使用三引号： 123456789class A: """ xxx """def func(): """ xxx """ 可以在语句添加一些必要的注释，不要在语句同一行后面添加注释 1234def func(): # 这是占位符 pass pass # 这是占位符,不允许使用 命名 模块、包、函数、方法、函数参数、变量使用意思完整的全小写英文描述(单词间可加上下划线)，例如webserver或者web_server 类名称首字母大写，采用驼峰命名法CapWords风格，例如MyClass 编码 对象与None作比较时，使用is/is not,不要用== 异常处理采用try…except…except…[else…][finally…)结构（else可省略）异常捕获要明确处理的是哪种异常 获取dict某个键的值采用dict.get(key),不使用dict[key] 内部元素确定的序列采用tuple存储 列表内的字符串连接采用join方法，不采用切片方式 对象类型检查使用isinstance方式，不要type方式 序列的复杂处理可以采用推导式，逻辑太复杂的写函数 慎用lambda和高阶函数(reduce,map,sort,filter)，逻辑太复杂的写函数 递归处理不要超过三层 功能测试性质的代码放在”if name == ‘main‘:” logging日志记录模块单文件放置，其他模块引入(from mylogger import logger) 123456789101112131415# mylogger.pyimport logginglogger = logging.getLogger()# 先给logger设置一个基础Level，不设置默认为WARNING，重要！logger.setLevel(logging.DEBUG)# 创建一个handler，用于写入日志文件scan_log = logging.FileHandler("scan.log")scan_log.setLevel(logging.DEBUG)# 定义handler的输出格式formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')scan_log.setFormatter(formatter)# 给logger添加handlerlogger.addHandler(scan_log) 多线程和多进程使用Queue来协调管理任务和任务间的通信 函数默认参数不要使用list等可变对象(空列表用None代替) 123456789def func(bar=None): if bar is None: bar = [] bar.append("aaa") return bar# 错误方式def func(bar=[]): bar.append("aaa") return bar 无关代码但是与模块逻辑有关的需要删除，安全性高的代码打包前需要Cython模块编译为pyd文件，密钥等关键数据建议使用pycryptodome模块加密http://www.lizenghai.com/archives/898.html 重复性的代码要封装成可复用的函数和方法]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xadmin将导入的excel文件保存到数据库]]></title>
    <url>%2F2019%2F03%2F26%2Fxadmin%E5%A6%82%E4%BD%95%E5%B0%86%E5%AF%BC%E5%85%A5excel%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[xadmin将导入的excel文件保存到数据库12345678910111213141516171819202122class EnvironmentAdmin(object): import_excel = True # 允许通过EXCEl导入 def post(self, request,*args, **kwargs): if 'excel' in request.FILES: execl_file = request.FILES.get('excel') files = xlrd.open_workbook(filename=None, file_contents=execl_file.read()) # 获取excel第一个表 rsheet = files.sheet_by_index(0) nrows = rsheet.nrows IP_pattern = re.compile( r"^(?:[0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;$") # 第一行一般为表头，所以从第二行开始取值 # Environment.objects.create() # 一条一条的导入数据 # Environment.objects.bulk_create() # 批量导入数据 # Environment.objects.update_or_create() # 导入一条或更新数据 # python manage.py dumpdata &gt; netcheck.json for j in range(1, nrows): a = rsheet.row_values(j)[0] b = rsheet.row_values(j)[1] Environment.objects.create(a=a, b=b, proposer=str(request.user.username)) return super(EnvironmentAdmin, self).post(request,args, kwargs)]]></content>
      <categories>
        <category>xadmin</category>
      </categories>
      <tags>
        <tag>xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7 下通过nginx+uwsgi部署django应用笔记]]></title>
    <url>%2F2019%2F01%2F15%2Fcentos7-%E4%B8%8B%E9%80%9A%E8%BF%87nginx-uwsgi%E9%83%A8%E7%BD%B2django%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.安装python3.61.准备工作 yum update yum install gcc 2.获取 wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz tar -xzvf Python-3.6.5.tgz -C /tmp cd /tmp/Python-3.6.5/ 3.安装 把Python3.6安装到 /usr/local 目录 ./configure --prefix=/usr/local make make install 4.更改/usr/bin/python链接 ln -s /usr/local/bin/python3.6 /usr/bin/python3（不要替换centos7自带的python，会出现一些问题） 2.安装mariadb1.安装 sudo yum install mariadb-server 2.启动， 重启，设置自启动， sudo systemctl start mariadb sudo systemctl restart mariadb sudo systemctl enable mariadb 3.设置bind-ip vim /etc/my.cnf 在 [mysqld]: 下面加一行 bind-address = 0.0.0.0 4.设置密码： mysqladmin -u root password &apos;123456&apos; 5.设置外部ip可以访问 先进入mysql才能运行下面命令: mysql 直接进入就行 GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; FLUSH PRIVILEGES； 6.创建数据库，恢复本地数据库备份到服务器 create database mxshop charset utf8; 将本地备份的数据库文件恢复到mariadb use mxshop; source mxshop.sql; 3.安装依赖环境1.安装redis yum install epel-release yum install redis systemctl start redis systemctl enable redis ps -ef | grep redis 2.安装虚拟环境和django应用依赖库 yum install python-pip pip install virtualenv,virtualenvwrapper 编辑.bashrc文件 export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh source ~/.bashrc 创建虚拟环境并激活: mkvirtualenv venv --python=/usr/bin/python3 mysqlclient安装前需要 yum install python-devel mariadb-devel -y 安装依赖包：pip install -r requirements.txt python manage.py runserver 这一步没问题再继续 4.安装nginx:1.安装nginx和开放http服务与端口 https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7 yum install nginx systemctl start nginx systemctl enable nginx sudo firewall-cmd --permanet --zone=public --add-service=http sudo firewall-cmd --permanet --zone=public --add-service=https sudo firewall-cmd --reload 在浏览器访问设备IP或绑定的域名：出现nginx欢迎页面表示成功 2.创建conf/nginx/mxshop.conf https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html 项目目录(~/projects/mxshop)创建conf/nginx/mxshop.conf，内容如下 12345678910111213141516171819202122232425262728293031323334# mxshop.conf# the upstream component nginx needs to connect toupstream django &#123; # server unix:///path/to/your/mysite/mysite.sock; # for a file socket server 127.0.0.1:8000; # for a web port socket (we&apos;ll use this first)&#125;# configuration of the serverserver &#123; # the port your site will be served on listen 80; # the domain name it will serve for server example.com; # 设备IP地址或者绑定的域名 charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media location /media &#123; alias /path/to/your/mysite/media; # your Django project&apos;s media files - amend as required &#125; location /static &#123; alias /path/to/your/mysite/static; # your Django project&apos;s static files - amend as required &#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include /path/to/your/mysite/uwsgi_params; # the uwsgi_params file you installed &#125;&#125; 3. 将该配置文件加入到nginx的启动配置文件中 创建软连接，一定要用绝对路径： sudo ln -s ~/projects/mxshop/conf/nginx/mxshop.conf /etc/nginx/conf.d/ 4.收集静态文件 STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;) python manage.py collectstatic 5.检查nginx语法错误并重启 /etc/nginx/nginx.conf 修改nginx用户为当前登录用户 sudo /usr/sbin/nginx -t systemctl restart nginx 6.虚拟环境安装uwsgipip install uwsgi https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html 1.测试uwsgi 创建hello.py 内容为以下内容 def hello_world(env, start_response): start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/plain&apos;)]) return [&apos;Hello, World!\r\n&apos;] uwsgi --http:8000 --wsgi-file hello.py 访问域名:8000端口，返回helloworld 测试django项目 uwsgi --http:8000 --module MxShop.wsgi 重启nginx确定没问题后: uwsgi --socket 127.0.0.1:800 --module MxShop.wsgi --chmod-socket 访问域名:8000端口，成功再进行下一步 2.uwsgi.ini方式启动 项目目录(~/projects/mxshop)创建conf/uwsgi/mxshop_uwsgi.ini 1234567891011121314151617181920212223官方文档# mysite_uwsgi.ini file[uwsgi]# Django-related settings# the base directory (full path)chdir = /path/to/your/project# Django&apos;s wsgi filemodule = project.wsgi# the virtualenv (full path)home = /path/to/virtualenv# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 10# the socket (use the full path to be safesocket = /path/to/your/project/mysite.sock# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = true 运行命令： uwsgi --ini ~/projects/mxshop/conf/uwsgi/mxshop_uwsgi.ini &amp; 12345678910111213141516171819202122232425我目前采用的ini文件# mysite_uwsgi.ini file[uwsgi]# Django-related settings# the base directory (full path)chdir = /path/to/your/project# Django&apos;s wsgi filemodule = project.wsgi# the virtualenv (full path)# home = /path/to/virtualenv# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 10# the socket (use the full path to be safe# socket = /path/to/your/project/mysite.socksocket = 设备IP# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = truelogto = /tmp/mylog.log 到此为止人工部署完成可以安装supervisord设置nginx和uwsgi为守护进程，进程挂掉会自动重启]]></content>
  </entry>
  <entry>
    <title><![CDATA[django应用部署清单]]></title>
    <url>%2F2019%2F01%2F13%2Fdjango%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1.准备工作1.settings模块拆分 settings模块所在目录创建settings包文件 settings:base.py,production.py,development.py 2.创建secret_key.txt 文件，加密SECRET_KEY后存储在这里 2.production.py1.关闭DEBUG模式 2.设置ALLOWED_HOSTS = [hosts] #一般为设备IP 3.修改数据库dict为服务器配置，并设置数据库连接最大存活时间CONN_MAX_AGE 4.配置缓存，这里为redis 5.配置错误日志记录和错误邮件发送 6.配置STATIC_ROOT,MEDIR_ROOT 7.安全中间件设置和HTTP安全设置 3.production必要配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149SECRET_KEY 通过环境变量或者加密模块进行加密DEBUG = FalseALLOWED_HOSTS = [hosts] #一般为设备IPSTATIC_ROOT = os.path.join(BASE_DIR, 'static')DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': "xx", 'USER': "user", 'PASSWORD': "123456", 'HOST': "设备IP", "PORT": 3306， 'CONN_MAX_AGE':60 # 单位为s &#125;&#125;CACHES = &#123; "default": &#123; "BACKEND": "django_redis.cache.RedisCache", # redis服务器的ip地址及端口号,及数据库序号,redis一共有15个数据库 0~15 "LOCATION": "redis://127.0.0.1:6379/6", "OPTIONS": &#123; "CLIENT_CLASS": "django_redis.client.DefaultClient", &#125; &#125;&#125;# 邮件发送模块EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'EMAIL_HOST = ""EMAIL_PORT = 25EMAIL_HOST_USER = ""encodestr = ''EMAIL_HOST_PASSWORD = str(base64.b64decode(encodestr), 'utf-8')EMAIL_FROM = ""EMAIL_USE_TLS = FalseSERVER_EMAIL = EMAIL_FROMEMAIL_SUBJECT_PREFIX = '[xx]'# the logging setting of project# 生产环境的配置是这样，定义一个生产环境的过滤器，用户访问发生的500系列的错误会发送给管理员ADMINS = ( ('admin', "xx"), # 管理员邮箱设置)SEND_BROKEN_LINK_EMAILS = TrueMANAGERS = ADMINSLOGGING = &#123; 'version': 1, 'disable_existing_loggers': True, # 表示停用django第三方工具包的日志 'formatters': &#123; 'standard': &#123; 'format': '%(asctime)s [%(threadName)s:%(thread)d] [%(name)s:%(lineno)d] [%(module)s:%(funcName)s] [%(levelname)s]- %(message)s'&#125; # 日志格式 &#125;, 'filters': &#123; 'require_debug_false': &#123; '()': 'django.utils.log.RequireDebugFalse', &#125;, &#125;, # 日志过滤器，DebugFalse表示Debug关闭后才会生效 'handlers': &#123; # 处理器 'null': &#123; 'level': 'DEBUG', 'class': 'logging.NullHandler', &#125;, 'mail_admins': &#123; # 邮件通知管理员 'level': 'ERROR', 'class': 'django.utils.log.AdminEmailHandler', 'filters': ['require_debug_false'], 'include_html': True, # 发送邮件携带出错页面 &#125;, 'debug': &#123; # 记录到日志文件（需要创建相应的目录） 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'filename': os.path.join(BASE_DIR, 'log', 'debug.log'), # 日志输出文件 'maxBytes': 1024 * 1024 * 5, # 文件大小 'backupCount': 5, # 备份份数 'formatter': 'standard', # 使用哪种formatters日志格式 &#125;, 'error': &#123; # 记录到日志文件（需要创建相应的目录） 'level': 'ERROR', 'class': 'logging.handlers.RotatingFileHandler', 'filename': os.path.join(BASE_DIR, 'log', 'error.log'), # 日志输出文件 'maxBytes': 1024 * 1024 * 5, # 文件大小 'backupCount': 5, # 备份份数 'formatter': 'standard', # 使用哪种formatters日志格式 &#125;, 'console': &#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'standard', # 使用哪种formatters日志格式 &#125;, &#125;, 'loggers': &#123; # logging管理器 'django': &#123; 'handlers': ['console'], 'level': 'DEBUG', 'propagate': True &#125;, 'django.request': &#123; 'handlers': ['mail_admins', 'error'], 'level': 'ERROR', 'propagate': False &#125;, 'django.security.DisallowedHost': &#123; 'handlers': ['null'], 'propagate': False &#125; &#125;&#125;# 下面的可选# Whether the session cookie should be secure (https:// only).# 使用安全 cookie# SESSION_COOKIE_SECURE = True# CSRF_COOKIE_SECURE = True######################## SECURITY MIDDLEWARE ########################SECURE_BROWSER_XSS_FILTER = TrueSECURE_CONTENT_TYPE_NOSNIFF = TrueSECURE_HSTS_INCLUDE_SUBDOMAINS = True# 使用 HTTP 严格传输安全协议（HSTS）SECURE_HSTS_PRELOAD = True# 设置SECURE_HSTS_SECONDS会不可逆转地破坏您的网站"""HTTP严格传输安全性允许网站通知浏览器它永远不应使用HTTP加载站点，并应自动转换所有使用HTTP到HTTPS请求访问站点的尝试。它包含一个HTTP头，Strict-Transport-Security，由服务器用资源发回。换句话说，如果您将值设置SECURE_HSTS_SECONDS为例如518400（6天），您的网络服务器将在他第一次访问您的网站时通知您的客户的浏览器https，以便将来专门访问您的网站。这适用于整个定义的时期。如果由于任何原因您不再通过https浏览器访问您的网站，则无法再访问您的服务。因此，您应该首先将此变量设置为类似60s的低值，并确保一切都按预期工作，否则您可能会阻止自己和您的客户访问您的网站。"""# SECURE_HSTS_SECONDS = 60# 全部采用 HTTPS连接# 这个要先去申请SSL证书并进行一定的设置# SECURE_SSL = True# SECURE_SSL_REDIRECT = True# Default X-Frame-Options header valueX_FRAME_OPTIONS = 'DENY']]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python算法(二)]]></title>
    <url>%2F2018%2F10%2F27%2FPython%E7%AE%97%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.列表复制问题123list1=[None,None]list2=list1*2 --&gt;[None,None,None,None]list3=[list1]*2 --&gt;[[None,None],[None,None]] 2.求列表第三大的那个值1234567891011121314151617# 求列表第三大的那个值def thirdMax(list1): max1 = list1[0] max2 = list1[1] max3 = list1[2] for k in list1: if k &gt; max1: max1, max2, max3 = k, max1, max2 elif k &gt; max2: max2, max3 = k, max2 elif k &gt; max3: max3 = k return max3list1=[1,4,8,5,6,7,9]thirdMax(list1) 3.台阶问题/斐波那契一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2) 第二种记忆方法1234567891011121314def memo(func): cache = &#123;&#125; def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap@memodef fib(i): if i &lt; 2: return 1 return fib(i-1) + fib(i-2) 第三种方法12345def fib(n): a, b = 0, 1 for _ in xrange(n): a, b = b, a + b return b 变态台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1) 4.去除列表中的重复元素用集合 1list(set(l)) 用字典 123l1 = ['b','c','d','b','c','a','a']l2 = &#123;&#125;.fromkeys(l1).keys()print l2 用字典并保持顺序 1234l1 = ['b','c','d','b','c','a','a']l2 = list(set(l1))l2.sort(key=l1.index)print l2 列表推导式 123456l1 = ['b','c','d','b','c','a','a']l2 = [][l2.append(i) for i in l1 if not i in l2]for i in l1: if i not in l2: l2.append(i) sorted排序并且用列表推导式. l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’][single.append(i) for i in sorted(l) if i not in single]print single 5.创建字典的方法1 直接创建1dict = &#123;'name':'earth', 'port':'80'&#125; 2 工厂方法123items=[('name','earth'),('port','80')]dict2=dict(items)dict1=dict((['name','earth'],['port','80'])) 3 fromkeys()方法123456789dict1=&#123;&#125;.fromkeys(('x','y'),-1)dict=&#123;'x':-1,'y':-1&#125;dict2=&#123;&#125;.fromkeys(('x','y'))dict2=&#123;'x':None, 'y':None&#125;# 4 zip方法keys = ['a','b']values = [1,2]dict1= dict(zip(keys,values)) 6.合并两个有序列表 pop弹出 12345678910111213141516a = [1,2,3,7]b = [3,4,5]def merge_sortedlist(a,b): c = [] while a and b: if a[0] &gt;= b[0]: c.append(b.pop(0)) else: c.append(a.pop(0)) while a: c.append(a.pop(0)) while b: c.append(b.pop(0)) return cprint merge_sortedlist(a,b)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据结构]]></title>
    <url>%2F2018%2F10%2F26%2FPython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.实现一个队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 首先获取节点，包含next指针和该节点位置上元素的值class Node(object): def __init__(self, val): self.next = None self.val = valclass Queue(object): def __init__(self): self.first = None self.last = None # 进队操作 def enter(self, n): # 实例节点 n = Node(n) # 进队之前先判断队列是否为空，即判断first是否为None if self.first == None: # 此时last==first==n self.first = n self.last = self.first else: # 将last的指针设置为n，值设置为n self.last.next = n self.last = n # 出队 def quit(self): if self.first == None: return None else: tmp = self.first.val self.first = self.first.next return tmp # 保存队列元素到列表 def allQuit(self): Lists = [] while self.first != None: Lists.append(self.first.val) self.first = self.first.next return Listsif __name__ == &apos;__main__&apos;: q = Queue() q.enter(1) q.enter(2) q.enter(3) # print(q.quit()) # print(q.quit()) # print(q.quit()) # print(q.quit()) print(q.allQuit()) 参考博客园 2.实现一个堆栈12345678910111213141516171819202122232425262728293031323334353637383940class Stack(object): def __init__(self): self.top = None # 获取栈顶的值 def peek(self): if self.top != None: return self.top.val else: return None # 入栈操作 def push(self, n): n = Node(n) # 实例化节点 n.next = self.top self.top = n return n.val # 出栈操作 def pop(self): if self.top == None: return None else: tmp = self.top.val # return self.top.val self.top = self.top.next # 栈顶元素下移一位 return tmpif __name__ == &apos;__main__&apos;: s = Stack() # s.peek() s.push(1) print(s.peek()) s.push(2) print(s.peek()) s.push(3) print(s.peek()) print(s.pop()) print(s.pop()) print(s.pop()) print(s.pop()) 参考 3.用Python实现一个单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&quot;&quot;&quot;节点类&quot;&quot;&quot;class Node(object): def __init__(self, data): self.data = data self.nex = Nonedef __init__(self): &quot;&quot;&quot;初始化链表&quot;&quot;&quot; self.head = Nonedef __len__(self): pre = self.head length = 0 while pre: length += 1 pre = pre.nex return length&quot;&quot;&quot;追加节点&quot;&quot;&quot;def append(self, data): &quot;&quot;&quot; 1.head 为none :head--&gt;node 2.tail.nex--&gt;node :param data: :return: &quot;&quot;&quot; node = Node(data) if self.head is None: self.head = node else: pre = self.head while pre.nex: pre = pre.nex pre.nex = node# 获取节点def get(self, index): &quot;&quot;&quot; :param index: :return: &quot;&quot;&quot; index = index if index &gt;= 0 else len(self) + index if len(self) &lt; index or index &lt; 0: return None pre = self.head while index: pre = pre.nex index -= 1 return pre&quot;&quot;&quot;设置节点&quot;&quot;&quot;def set(self, index, data): node = self.get(index) if node: node.data = data return node&quot;&quot;&quot;插入节点&quot;&quot;&quot;def insert(self, index, data): &quot;&quot;&quot; 1.index 插入节点位置包括正负数 2.找到index-1--&gt;pre_node的节点 3.pre_node.next--&gt;node node.next--&gt;pre_node.next.next 4.head :param index: :param data: :return: &quot;&quot;&quot; node = Node(data) if abs(index + 1) &gt; len(self): return False index = index if index &gt;= 0 else len(self) + index + 1 if index == 0: node.nex = self.head self.head = node else: pre = self.get(index - 1) if pre: nex = pre.nex pre.nex = node node.nex = nex else: return False return node&quot;&quot;&quot;删除某个元素&quot;&quot;&quot;def delete(self, index): f = index if index &gt; 0 else abs(index + 1) if len(self) &lt;= f: return False pre = self.head index = index if index &gt;= 0 else len(self) + index prep = None while index: prep = pre pre = pre.nex index -= 1 if not prep: self.head = pre.nex else: prep.nex = pre.nex return pre.data&quot;&quot;&quot;反转链表&quot;&quot;&quot;def __reversed__(self): &quot;&quot;&quot; 1.pre--&gt;next 转变为 next--&gt;pre 2.pre 若是head 则把 pre.nex --&gt; None 3.tail--&gt;self.head :return: &quot;&quot;&quot; def reverse(pre_node, node): if pre_node is self.head: pre_node.nex = None if node: next_node = node.nex node.nex = pre_node return reverse(node, next_node) else: self.head = pre_node return reverse(self.head, self.head.nex)&quot;&quot;&quot;清空链表&quot;&quot;&quot;def clear(self): self.head = None 参考 4.二叉树节点12345678class Node(object): def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = righttree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4))) 5.前中后序遍历12345678910111213141516171819202122232425262728293031323334353637#coding:utf-8#二叉树的遍历#简单的二叉树节点类class Node(object): def __init__(self,value,left,right): self.value = value self.left = left self.right = right#中序遍历:遍历左子树,访问当前节点,遍历右子树def mid_travelsal(root): if root.left is None: mid_travelsal(root.left) #访问当前节点 print(root.value) if root.right is not None: mid_travelsal(root.right)#前序遍历:访问当前节点,遍历左子树,遍历右子树def pre_travelsal(root): print (root.value) if root.left is not None: pre_travelsal(root.left) if root.right is not None: pre_travelsal(root.right)#后续遍历:遍历左子树,遍历右子树,访问当前节点def post_trvelsal(root): if root.left is not None: post_trvelsal(root.left) if root.right is not None: post_trvelsal(root.right) print (root.value) 6.前序中序求后序123456789101112131415def rebuild(pre, center): if not pre: return cur = Node(pre[0]) index = center.index(pre[0]) cur.left = rebuild(pre[1:index + 1], center[:index]) cur.right = rebuild(pre[index + 1:], center[index + 1:]) return curdef deep(root): if not root: return deep(root.left) deep(root.right) print root.data 推荐: http://blog.csdn.net/hinyunsin/article/details/6315502]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础与深入(六)]]></title>
    <url>%2F2018%2F10%2F18%2FPython%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B7%B1%E5%85%A5-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[一.装饰器装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有计时统计、插入日志、缓存计算结果、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。装饰器的作用和功能： 引入日志 函数执行时间统计 执行函数前预备处理 执行函数后的清理功能 权限校验等场景 缓存 下面举例说明 1.装饰器用做日志记录123456789from functools import wrapperdef log(func): @functools.wraps(func) # 将func的属性传递给wrapper def wrapper(*args, **kw): print('call %s():' % func.__name__) f=func(*args, **kw) print('end call %s():' % func.__name__) return f return wrapper 2.如何定义带参数的装饰器12345678910111213141516171819202122232425import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print(&apos;%s %s():&apos; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator# 同时支持@log和@log(&apos;execute&apos;)def log2(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): if isinstance(text,str): print(&apos;%s %s():&apos; % (text, func.__name__)) else: print(&apos;%s():&apos; % func.__name__) return func(*args, **kw) return wrapper if callable(text): return decorator(text) else: return decorator 3.装饰器用做执行时间统计1234567891011from functools import wrapperfrom time import timedef countTime(func): @functools.wraps(func) def wrapper(*args, **kwargs): start = time.time() func(*args, **kwargs) print(&quot;函数&#123;0&#125;执行时间为：&#123;1&#125;s&quot;.format(func.__name__, time.time() - start)) return func return wrapper 4.装饰器用做缓存12345678910111213141516def cache(func): cache_dict = &#123;&#125; @functools.wraps(func) def wrapper(*args): if args not in cache_dict: cache_dict[args] = func(*args) return cache_dict[args] return wrapper@cachedef fibonacci(n): if n &lt;= 1: return 1 cache_dict = fibonacci(n - 1) + fibonacci(n - 2) return cache_dict 二. __new__和__init__的区别这个__new__确实很少见到,先做了解吧. __new__是一个静态方法,而__init__是一个实例方法. __new__方法会返回一个创建的实例,而__init__什么都不返回. 只有在__new__返回一个cls的实例时后面的__init__才能被调用. 当创建一个新实例时调用__new__,初始化一个实例时用__init__. 三.单例模式单例模式伯乐在线详细解释 1.使用__new__方法123456789class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instanceclass MyClass(Singleton): a = 1 2.装饰器版本1234567891011def singleton(cls): instances = &#123;&#125; def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance@singletonclass MyClass: ... 3.import方法作为python的模块是天然的单例模式 1234567891011# mysingleton.pyclass My_Singleton(object): def foo(self): passmy_singleton = My_Singleton()# to usefrom mysingleton import my_singletonmy_singleton.foo() 4.使用元类123456789class Singleton(type): _instances=&#123;&#125; def __call__(cls,*args,**kwargs): if cls not in cls._instances: cls._instances[cls]=super(Singleton,cls).__call__(*args,**kwargs) return cls._instances[cls]class MyClass(metaclass=Singleton): pass 四.Python中的作用域Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索： 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python算法(一)]]></title>
    <url>%2F2018%2F10%2F15%2FPython%E7%AE%97%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.归并排序12345678910111213141516171819202122232425262728293031323334def merge(a, b): c = [] h = j = 0 # 依次便利，拿到兩個數組更小的元素， while j &lt; len(a) and h &lt; len(b): # 如果0索引位置的元素a更小，添加a[0]到c，再將a[1]與b[0]比較，依次類推，剩余最后的元素就是两个数组的最大值 if a[j] &lt; b[h]: c.append(a[j]) j += 1 else: c.append(b[h]) h += 1 if j == len(a): for i in b[h:]: c.append(i) else: for i in a[j:]: c.append(i) return cdef merge_sort(lists): if len(lists) &lt;= 1: return lists middle = len(lists)//2 left = merge_sort(lists[:middle]) right = merge_sort(lists[middle:]) return merge(left, right)if __name__ == &apos;__main__&apos;: a = [4, 7, 8, 3, 5, 9,10] print(merge_sort(a)) 2.快排1234567891011121314151617#coding:utf-8def quicksort(list): if len(list)&lt;2: return list else: midpivot = list[0] lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot] biggerafterpivot = [i for i in list[1:] if i &gt; midpivot] finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot) return finallylistprint quicksort([2,4,6,7,1,2,5])# 使用lambda函数实现quicksort=lambda data:data if len(data)&lt;2 else quicksort([item for item in data[1:] if item&lt;=data[0]])+[data[0]]+quicksort([item for item in data[1:] if item&gt;data[0]])print quicksort([2,4,6,7,1,2,5]) 3.二分查找1234567891011121314151617#coding:utf-8def binary_search(data, item): low = 0 high = len(data) - 1 while low &lt;= high: mid = (low + high) // 2 guess = data[mid] if item &lt; guess: high = mid - 1 elif item &gt; guess: low = mid + 1 elif item == guess: return mid return Nonemylist = [1,3,5,7,9]print binary_search(mylist,3) 4.质数问题1234567891011121314151617181920def is_prime_number(k): if k&lt;2: return False for i in range(2,k): if k%i==0: return False return Truedef get_prime_number(start,end): # prime_numbers = [] for k in range(start,end+1): if is_prime_number(k): yield k # prime_numbers.append(k) # return prime_numbersprime_numbers = get_prime_number(1,100)# print(next(prime_numbers))for i in prime_numbers: print(i) 5.日期问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 写一个函数，计算给定日期是该年的第几天和周数def count(year,month,day): count=0 if (year%4==0 and year%100!=0) or year%400==0: print(&apos;%d年是闰年，2月份有29天！&apos;%year) list1=[31,29,31,30,31,30,31,31,30,31,30,31] for i in range(month-1): count=count+list1[i] return count+ else: print(&apos;%d年是平年，2月份有29天！&apos; % year) li2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] for i in range(month-1): count +=li2[i] return count+dayif __name__ == &quot;__main__&quot;: year = int(input(&apos;请输入年份：&apos;)) month = int(input(&apos;请输入月份：&apos;)) day = int(input(&apos;请输入日期：&apos;)) count = count(year,month,day) print(&apos;%d年%d月%d日是今年的第%d天！&apos;%(year,month,day,count))from functools import reduce# 写一个函数，计算给定日期是该年的第几天和周数class WhichDay(object): def __init__(self,date): self.year = int(date.year) self.month = int(date.month) self.day = int(date.day) self.run_nian= [31,29,31,30,31,30,31,31,30,31,30,31] self.ping_nian = [31,28,31,30,31,30,31,31,30,31,30,31] def count(self): if (self.year%4==0 and self.year%100!=0) or self.year%400==0: print(&quot;该年为闰年&quot;) print(self.run_nian[:self.month]) count = reduce(lambda x,y:x+y,self.run_nian[:self.month-1]) + self.day else: print(self.ping_nian[:self.month]) count = reduce(lambda x,y:x+y,self.ping_nian[:self.month-1]) + self.day return countif __name__ == &quot;__main__&quot;: from datetime import datetime # from datetime import date # date1 = date(2017,6,11) # wd = WhichDay(date(2017,6,11)) date_str=&apos;20170611&apos; date=datetime.strptime(date_str,&apos;%Y%m%d&apos;) print(date.year,date.month,date.day) wd = WhichDay(date) print(&quot;&#123;0&#125;是当年的第&#123;1&#125;天&quot;.format(date_str,wd.count()))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础与深入(五)]]></title>
    <url>%2F2018%2F10%2F10%2FPython%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B7%B1%E5%85%A5-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[1.正则表达式相关知识及字符串操作参考廖雪峰 字符串拼接join方法str.join(iterable) 12L = [&quot;&lt;0112&gt;&quot;, &quot;&lt;32&gt;&quot;, &quot;&lt;1024x768&gt;&quot;, 60, &quot;&lt;1&gt;&quot;, &quot;&lt;100.0&gt;&quot;, &quot;&lt;500.0&gt;&quot;]print(&apos;&apos;.join(str(x) for x in L)) 如何判断字符串a是否以字符串b开头或结尾,str.startswith(),str.endswith() 12a=&quot;abcdefg||fadfa.py&quot;a.endswith((&apos;.py&apos;,&apos;.sh&apos;)) 如何用Python来进行查询和替换一个文本字符串？ 12s = &apos;\tabd\t124\txyz\r\n&apos;print(re.sub(&apos;\t|\r|\n&apos;,&apos;&apos;,s)) 一次性拆分字符串 re.split(),str.split() 12345678"""解决方案:方法一:连续使用是str.split()方法,每次处理一种分隔符号方法二:使用正则表达式的re.split()方法,一次性拆分字符串"""s = 'ab;cd|efg|hi,jklmn|topq;rst,uvw|txyz't = s.split(';')t1 = re.split(r'[,;|\t]+',s) Python里面match()和search()的区别？ 12re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。re模块中re.search(pattern,string[,flags]),在string搜索pattern的第一个匹配值。 Python re.findall()方法 1234#寻找一段字符串中的11位数字（手机号），返回列表import restr1=&quot;13832244324gdsjsfhauer13632996133&quot;re.findall(r&apos;\d&#123;11&#125;&apos;,str1) 用Python匹配HTML tag的时候，&lt;.&gt;和&lt;.?&gt;有什么区别？答：术语叫贪婪匹配( &lt;.&gt; )和非贪婪匹配(&lt;.?&gt; )前者是贪婪匹配，会从头到尾匹配 xyz，而后者是非贪婪匹配，只匹配到第一个 &gt;。 如何去掉字符串中不需要的字符 12345678910111213141516171819202122232425262728293031&quot;&quot;&quot;解决方案:方法1:字符串strip(),lstrip(),rstrip()方法去掉字符串两段字符方法2:删除单个固定位置的字符,可以使用切片+拼接的方式方法3:字符串的replace()方法或正则表达式re.sub()删除任意位置字符方法4:字符串translate()方法,可以同时删除多种不同字符&quot;&quot;&quot;s=&apos; nick2008@gmail.com &apos;print(s.strip(&apos; &apos;))print(&apos;----------------&apos;)s = &apos;====+-----&apos;print(s.strip(&apos;-=&apos;))print(&apos;----------------&apos;)s=&apos; nick2008 @gmail.com &apos;print(s[2:11]+s[12:23])print(&apos;----------------&apos;)s = &apos;\tabd\t124\txyz\r\n&apos;print(s.replace(&apos;\t&apos;,&apos;&apos;))print(&apos;----------------&apos;)s = &apos;\tabd\t124\txyz\r\n&apos;print(re.sub(&apos;\t|\r|\n&apos;,&apos;&apos;,s))print(&apos;----------------&apos;)s = &apos;\tabd\t124\txyz\r\n&apos;print(s.translate(None,&apos;\t\r\n&apos;))s = &apos;\tabd\t124\txyz\r\n&apos;print(s.replace(&apos;\t&apos;,&apos;&apos;))u = u&apos;uulàlà,là,māmá&apos;print u.translate(dict.fromkeys([0x0,0x0101,0x1])) 补充 单引号，双引号，三引号的区别 答：单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释 如果要表示Let’s go 这个字符串 单引号：s4 = ‘Let\’s go’ 双引号：s5 = “Let’s go” s6 = ‘I realy like“python”!’ 这就是单引号和双引号都可以表示字符串的原因了]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础与深入(四)]]></title>
    <url>%2F2018%2F10%2F06%2FPython%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B7%B1%E5%85%A5-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[1.GIL线程全局锁 Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。线程的执行速度非常之快，会让你误以为线程是并行执行的（并行），但是实际上都是轮流执行（并发或者串行）。对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 在多线程环境中，Python 虚拟机按以下方式执行： 设置GIL 切换到一个线程去运行 运行： a. 指定数量的字节码指令，或者 b. 线程主动让出控制（可以调用time.sleep(0)） 把线程设置为睡眠状态 解锁GIL 再次重复以上所有步骤在调用外部代码（如C/C++扩展函数）的时候，GIL 将会被锁定，直到这个函数结束为止（由于在这期间没有Python 的字节码被运行，所以不会做线程切换）。join方法 子进程结束切换到父进程多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。 2.Python函数式编程python中函数式编程支持:filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。 1234&gt;&gt;&gt;a = [1,2,3,4,5,6,7]&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)&gt;&gt;&gt;print b&gt;&gt;&gt;[6,7] map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2： 123&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])&gt;&gt;&gt; list(a)[2, 4, 6] reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘： 12&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))6 filter函数用于对序列的每个项进行迭代，不满足条件的就会被踢出序列12&gt;&gt;&gt; filter(lambda x&gt;0:x,range(-10,4))[1,2,3] 补充：用filter求素数1234567891011121314151617181920def _odd_iter(): n = 1 while True: n = n + 2 yield ndef _not_divisible(n): return lambda x: x % n &gt; 0def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列# 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break 3.Python里的拷贝引用和copy(),deepcopy()的区别 1234567891011121314151617181920import copya = [1, 2, 3, 4, ['a', 'b']] #原始对象b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝a.append(5) #修改对象aa[4].append('c') #修改对象a中的['a', 'b']数组对象print 'a = ', aprint 'b = ', bprint 'c = ', cprint 'd = ', d输出结果：a = [1, 2, 3, 4, ['a', 'b', 'c'], 5]b = [1, 2, 3, 4, ['a', 'b', 'c'], 5]c = [1, 2, 3, 4, ['a', 'b', 'c']]d = [1, 2, 3, 4, ['a', 'b']] 切片的对象，切片是浅拷贝还是深拷贝切片的对象有list,tuple,str“=”,copy,slice属于浅拷贝deepcopy就属于深拷贝浅拷贝和深拷贝的区别在于深拷贝是被复制的对象作为一个新的个体独立存在,任意改变其一不会对另一个对象造成影响,而浅拷贝不会产生新的独立对象 4.Python是如何进行内存管理的(http://developer.51cto.com/art/201007/213585.html) 答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制 1、对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况： 1，一个对象分配一个新名称 2，将其放入一个容器中（如列表、元组或字典） 引用计数减少的情况： 1，使用del语句对对象别名显示的销毁 2，引用超出作用域或被重新赋值 sys.getrefcount( )函数可以获得对象的当前引用计数 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。 2、垃圾回收 1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。 2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用， 因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 3、内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 5.Python的is和==is是对比地址,==是对比值is 比较的是两个实例对象是不是完全相同,is关键字是查看两个对象是否相同的唯一标准，他们是不是同一个对象,占用的内存地址是否相同,即比较他们的id== 比较的是两个实例对象的内容是否相同,即他们的内存地址可以不同,默认调用eq方法切片slice is-&gt;False ==-&gt;True序列直接复制= is-&gt;True大量创建相同内容的字符串，is-&gt;True小整数对象[-5,256]在全局解释器范围内被放入缓存共重复使用a=1 b=1 a is b -&gt;True ==-&gt;Truea=257 b=257 a is b -&gt;True ==-&gt;True is运算符比==效率高,在变量和None进行比较时,应该使用is 6.read,readline和readlines read 读取整个文件 readline 读取下一行,使用生成器方法 readlines 读取整个文件到一个迭代器以供我们遍历 7.Python2和3的区别推荐：Python 2.7.x 与 Python 3.x 的主要差异 补充：Python的编码问题python3 bytes和str都可以代表字符序列,前者的实例包含原始的8位值;bytes.decode(‘utf-8’)后者的实例包含unicode字符 str.encode(‘utf-8’) python2 str和Unicode都可以代表字符序列,与python3不同的是,str的实例包含原始的8位值,str.decode(‘utf-8’)而Unicode的实例则包含unicode字符,unicode.encode(‘utf-8’) python2 str python3 bytespython2 unicode python3 str python2 str.decode(‘utf-8’)–&gt;unicodeunicode.encode(‘utf-8’)–&gt;strpython3 bytes.decode(‘utf-8’)–&gt;strstr.encode(‘utf-8’) –&gt;bytes 8.协程、线程和进程间的区别进程是资源分配和拥有的单位,进程包含多个线程，线程是指进程内的一个执行单元一个线程可以有多个协程，一个进程也可以单独拥有多个协程线程进程都是同步机制，而协程则是异步IO密集型一般使用多线程或者多进程，CPU密集型一般使用多进程，强调非阻塞异步并发的一般都是使用协程，当然有时候也是需要多进程线程池结合的，或者是其他组合方式。 进程是应用程序执行的基本单元，应用执行可以开多个进程multiprocessing模块线程是进程内的一个基本执行单元，每个进程可以开多个线程multithread.Thread类协程也叫微线程，一个线程可以包含多个协程gevent from gevent.pool import Pool]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础与深入(三)]]></title>
    <url>%2F2018%2F10%2F04%2FPython%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B7%B1%E5%85%A5-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[1.迭代器和生成器123456&gt;&gt;&gt; L = [x*x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt; 通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator ###大数据的文件读取123with open(path,'rb') as file: for line in file: print(file) ###yield语句的用法相当于给函数运行打断点，下次循环或者调用时在这里终止程序yield简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次（或n 次）调用跳转至该函树）调用跳转至该函数。 21 *args and **kwargs用*args和**kwargs只是为了方便并没有强制使用它们. 当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数: 12345678&gt;&gt;&gt; def print_everything(*args): for count, thing in enumerate(args):... print '&#123;0&#125;. &#123;1&#125;'.format(count, thing)...&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')0. apple1. banana2. cabbage 相似的,**kwargs允许你使用没有事先定义的参数名: 1234567&gt;&gt;&gt; def table_things(**kwargs):... for name, value in kwargs.items():... print '&#123;0&#125; = &#123;1&#125;'.format(name, value)...&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')cabbage = vegetableapple = fruit 你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如: 1def table_things(titlestring, **kwargs) *args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面. 当调用函数时你也可以用*和**语法.例如: 1234567&gt;&gt;&gt; def print_three_things(a, b, c):... print 'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'.format(a,b,c)...&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']&gt;&gt;&gt; print_three_things(*mylist)a = aardvark, b = baboon, c = cat]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础与深入(二)]]></title>
    <url>%2F2018%2F10%2F03%2FPython%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B7%B1%E5%85%A5-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1 使用property创建可管理的对象属性property可以让实例在形式上是属性访问,但实际上调用方法12345678910111213141516171819202122class Circle2(object): def __init__(self, radius): self.radius = radius def getRadius(self): # return self.radius return round(self.radius, 2) # 表示四舍五入后保留小数点后两位 def setRadius(self, value): if not isinstance(value, (int, long, float)): raise valueError(&apos;wrong type .&apos;) self.radius = float(value) def getArea(self): return self.radius * 2 * pi R = property(getRadius, setRadius)r = Circle2(3.2)print(r.R) # 自动调用getRadiusr.R = 5.4 # 自动调用setRadiusprint(r.R) # 自动调用getRadius 2.类属性和实例属性类属性： 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类属性，用于跟踪存在着多少个Test 的实例。 实例属性： 实例化之后，每个实例单独拥有的变量。 12345678910111213class Test(object): num_of_instance = 0 def __init__(self, name): self.name = name Test.num_of_instance += 1if __name__ == '__main__': print Test.num_of_instance # 0 t1 = Test('jack') print Test.num_of_instance # 1 t2 = Test('lucy') print t1.name , t1.num_of_instance # jack 2 print t2.name , t2.num_of_instance # lucy 2 补充的例子 123456789class Person: name="aaa"p1=Person()p2=Person()p1.name="bbb"print p1.name # bbbprint p2.name # aaaprint Person.name # aaa 这里p1.name=&quot;bbb&quot;是实例调用了类属性,这其实和上面第一个问题一样,就是函数传参的问题,p1.name一开始是指向的类属性name=&quot;aaa&quot;,但是在实例的作用域里把类属性的引用改变了,就变成了一个实例属性,self.name不再引用Person的类属性name了. 可以看看下面的例子: 123456789class Person: name=[]p1=Person()p2=Person()p1.name.append(1)print p1.name # [1]print p2.name # [1]print Person.name # [1] 参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block 3.Python自省自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance(). 12345a = [1,2,3]b = &#123;'a':1,'b':2,'c':3&#125;c = Trueprint type(a),type(b),type(c) # &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;print isinstance(a,list) # True 4.列表解析、集合解析代码示例如下： 1234list1=[x for x in range(100) if x%2==0] #或 [x for x in range(0,100,2)]#集合的列表生成式s=&#123;1,34,5,-7,6,87,-8,-9,11&#125;print(&#123;x for x in s if x%3==0&#125;) 5.Python中单下划线和双下划线1234567891011121314&gt;&gt;&gt; class MyClass():... def __init__(self):... self.__superprivate = "Hello"... self._semiprivate = ", world!"...&gt;&gt;&gt; mc = MyClass()&gt;&gt;&gt; print mc.__superprivateTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: myClass instance has no attribute '__superprivate'&gt;&gt;&gt; print mc._semiprivate, world!&gt;&gt;&gt; print mc.__dict__&#123;'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'&#125; __foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法 _foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问； __foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问. 详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python 或者: http://www.zhihu.com/question/19754941 6.字典、列表、元组、集合123456789101112131415161718192021222324252627282930313233343536373839# 补充：集合的交集并集等操作A=set([randint(1,20) for _ in range(10)])B=set([randint(1,20) for _ in range(10)])print(A&amp;B,A|B,A-B,A^B) #交，并，差，补from collections import namedtupleStudent = namedtuple('Student', ['name', 'age', 'sex', 'email'])Jim = Student('Jim', 16, 'male', 'jim8721@gamil.com')print(Jim.name)# 使用zip将字典数据转化为元组score = &#123; 'LiLei': 79, 'Jim': 88, 'Lucy': 92&#125;score4 = tuple(zip(score.values(),score.keys()))# 字典排序print(sorted(score.items(),key=lambda x:x[1])) #表示对生成的列表的元组索引第二位进行排序# 字典补充 k,v交换score2=&#123;v:k for k,v in score.items()&#125;score3=dict(zip(score2.values(),score2.keys()))# 统计元素出现的频度from collections import Counter, OrderedDictfrom random import randintimport redata = [randint(0, 20) for _ in range(30)] #产生30个0到20的随机整数print(Counter(data))print(Counter(data).most_common(3))# 创建有序的字典from functools import OrderedDictod = OrderedDict([('a', 1), ('b', 2), ('c', 3)]) 元组和列表的同异同：列表与元组都是容器，是一系列的对象。二者都可以包含任意类型的元素甚至可以是一个序列，还可以包含元素的顺序（不像集合和字典）。元组属于不可变对象，列表属于可变对象，列表的很多方法不适用于元组；元组可哈希而列表不可哈希；元组占用空间更小，代码的语义更好理解再函数式编程较常用。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础与深入(一)]]></title>
    <url>%2F2018%2F10%2F01%2FPython%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B7%B1%E5%85%A5-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.Python语言特性 Python是一种解释型语言。这就是说，与C语言和C的衍生语言不同，Python代码在运行之前不需要编译。 Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。 Python非常适合面向对象的编程（OOP），因为它支持通过组合（composition）与继承（inheritance）的方式定义类（class）。 Python中没有访问说明符（access specifier，类似C++中的public和private），这么设计的依据是“大家都是成年人了”。 在Python语言中，函数是第一类对象（first-class objects）。这指的是它们可以被指定给变量，函数既能返回函数类型，也可以接受函数作为输入。类（class）也是第一类对象。Python代码编写快，但是运行速度比编译语言通常要慢。好在Python允许加入基于C语言编写的扩展，因此我们能够优化代码，消除瓶颈，这点通常是可以实现的。numpy就是一个很好地例子，它的运行速度真的非常快，因为很多算术运算其实并不是通过Python实现的。 Python用途非常广泛——网络应用，自动化，科学建模，大数据应用，等等。它也常被用作“胶水语言”，帮助其他语言和组件改善运行状况。Python让困难的事情变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。 2.Python的命名空间在Python中，所有的名字都存在于一个空间中，它们在该空间中存在和被操作——这就是命名空间。 它就好像一个盒子，每一个变量名字都对应装着一个对象。当查询变量的时候，会从该盒子里面寻找相应的对象。 3.Python异常处理的用法和作用 [参考廖雪峰](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191375461417a222c54b7e4d65b258f491c093a515000] Python异常处理结构try…except…except…[else…][finally…) 执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。 如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行 如果存在finally语句，最后总是会执行。 12345678910111213try: print('try...') r = 10 / int('2') print('result:', r)except ValueError as e: print('ValueError:', e)except ZeroDivisionError as e: print('ZeroDivisionError:', e)else: print('no error!')finally: print('finally...')print('END') 4.Python的函数参数传递看两个例子: 12345a = 1def fun(a): a = 2fun(a)print a # 1 12345a = []def fun(a): a.append(1)fun(a)print a # [1] 所有的变量都可以理解是内存中一个对象的“引用” 通过id来看引用a的内存地址可以比较理解： 12345678a = 1def fun(a): print "func_in",id(a) # func_in 41322472 a = 2 print "re-point",id(a), id(2) # re-point 41322448 41322448print "func_out",id(a), id(1) # func_out 41322472 41322472fun(a)print a # 1 注：具体的值在不同电脑上运行时可能不同。 可以看到，在执行完a = 2之后，a引用中保存的值，即内存地址发生变化，由原来1对象的所在的地址变成了2这个实体对象的内存地址。 而第2个例子a引用保存的内存值就不会发生变化： 1234567a = []def fun(a): print "func_in",id(a) # func_in 53629256 a.append(1)print "func_out",id(a) # func_out 53629256fun(a)print a # [1] 这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可变”（mutable）与“不可变”（immutable）对象。在python中，string, tuple, 和number是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点) 当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改. 如果还不明白的话,这里有更好的解释: http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference 5.Python的List和Dict的实现原理推荐:列表字典 字典按照键值对的形式进行存储，时间复杂度为O(1) 字典的底层是通过哈希表实现的，使用开放地址法解决冲突。所以其查找的时间复杂度会是O(1)，哈希函数求哈希值(哈希函数就是一个多对一的映射) 6.函数的参数用法和注意事项(参考廖雪峰课程)[https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000]函数参数分为位置参数、默认参数、可变参数、关键字参数、命名关键字参数（定义和调用必须按顺序传入）12345678910111213141516171819202122232425numbers=[1,2,3,4,5]def sum(*args): sum=0 for i in args: sum = sum+i*i return sumsum(*numbers)dict1=&#123;&apos;a&apos;:1,&apos;b&apos;:2&#125;def f(**kwargs): for k,v in kwargs.items(): print(&apos;&#123;0&#125;:&#123;1&#125;&apos;.format(k,v))f(**dict1)# 如果需要约束传入的关键字参数的名称，可以用命名关键字参数# 命名关键字参数必须传入参数名，这和位置参数不同。def person(name, age, *, city, job): print(name, age, city, job)def person(name, age, *args, city, job): print(name, age, args, city, job)# 命名关键字参数可以有缺省值，从而简化调用：def person(name, age, *, city=&apos;Beijing&apos;, job): print(name, age, city, job) 7.可变对象和不可变对象 python所有数字类型(布尔树,整数,浮点数,复数)均为不可变对象, 可变对象:file,dict,set,list,bytesarray,range 不可变对象:boolean,int,float,complex,tuple,str,bytes,frozenset 有序sequence:str,list,tuple,OrderedDict, 无序:dict,set, 不可重复:set,tuple 可变对象(mutable object)has no hash value 不可变对象可哈希,hashable 8.def是运行时执行语句,并且是赋值语句类和对象均为第一类对象，调用的时候才会运行 9.Python是否能以可变对象做函数默认参数不可以,字典,集合,列表等可变对象不适合作为函数默认值要不然第二次调用时,一次调用的默认参数的值会影响二次调用.1234567def f(l=[]): for i in range(3): l.append(i) return lf(l=[2]),---- l=[2,0,1,2]f(), ---- l=[0,1,2]f(), ---- l=[0,1,2,0,1,2] 10.@staticmethod和@classmethodPython其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下: 12345678910111213141516def foo(x): print "executing foo(%s)"%(x)class A(object): def foo(self,x): print "executing foo(%s,%s)"%(self,x) @classmethod def class_foo(cls,x): print "executing class_foo(%s,%s)"%(cls,x) @staticmethod def static_foo(x): print "executing static_foo(%s)"%xa=A() 这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好. 对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用. \ 实例方法 类方法 静态方法 a = A() a.foo(x) a.class_foo(x) a.static_foo(x) A 不可用 A.class_foo(x) A.static_foo(x) 更多关于这个问题: http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python https://realpython.com/blog/python/instance-class-and-static-methods-demystified/]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
