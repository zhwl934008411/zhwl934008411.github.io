<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Table of Contents  Python语言特性  1 对Python的理解(对比其他语言)) 2 什么是Python的命名空间  3 Python中的pass语句 4 Python异常处理的用法和作用 5 Python的函数参数传递 6 函数的参数用法和注意事项 7 可变对象和不可变对象 8 def是运行时执行语句,并且是赋值语句 9 Python是否能以可变对象做函数默认参数 10">
<meta property="og:type" content="article">
<meta property="og:title" content="Python面试题（github+经验整合）">
<meta property="og:url" content="http://yoursite.com/2019/01/10/Python面试题-自我总结版本/index.html">
<meta property="og:site_name" content="Jeese&#39;s Blog">
<meta property="og:description" content="Table of Contents  Python语言特性  1 对Python的理解(对比其他语言)) 2 什么是Python的命名空间  3 Python中的pass语句 4 Python异常处理的用法和作用 5 Python的函数参数传递 6 函数的参数用法和注意事项 7 可变对象和不可变对象 8 def是运行时执行语句,并且是赋值语句 9 Python是否能以可变对象做函数默认参数 10">
<meta property="og:locale" content="zh-hans">
<meta property="og:updated_time" content="2019-02-21T19:48:34.526Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python面试题（github+经验整合）">
<meta name="twitter:description" content="Table of Contents  Python语言特性  1 对Python的理解(对比其他语言)) 2 什么是Python的命名空间  3 Python中的pass语句 4 Python异常处理的用法和作用 5 Python的函数参数传递 6 函数的参数用法和注意事项 7 可变对象和不可变对象 8 def是运行时执行语句,并且是赋值语句 9 Python是否能以可变对象做函数默认参数 10">






  <link rel="canonical" href="http://yoursite.com/2019/01/10/Python面试题-自我总结版本/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Python面试题（github+经验整合） | Jeese's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/zhwl934008411" class="github-corner" aria-label="View source on GitHub">
    <svg width="80" height="80" viewbox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jeese's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/10/Python面试题-自我总结版本/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeese zhao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jeese's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python面试题（github+经验整合）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-10 20:42:33" itemprop="dateCreated datePublished" datetime="2019-01-10T20:42:33+08:00">2019-01-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-22 03:48:34" itemprop="dateModified" datetime="2019-02-22T03:48:34+08:00">2019-02-22</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><p><a href="#python语言特性">Python语言特性</a></p>
<ul>
<li><a href="#1-对Python的理解(对比其他语言">1 对Python的理解(对比其他语言)</a>)</li>
<li><a href="#2-什么是Python的命名空间">2 什么是Python的命名空间 </a></li>
<li><a href="#3-Python中的pass语句">3 Python中的pass语句</a></li>
<li><a href="#4-Python异常处理的用法和作用">4 Python异常处理的用法和作用</a></li>
<li><a href="#5-python的函数参数传递">5 Python的函数参数传递</a></li>
<li><a href="#6-函数的参数用法和注意事项">6 函数的参数用法和注意事项</a></li>
<li><a href="#7-可变对象和不可变对象">7 可变对象和不可变对象</a></li>
<li><a href="#8-def是运行时执行语句,并且是赋值语句">8 def是运行时执行语句,并且是赋值语句</a></li>
<li><a href="#9-Python是否能以可变对象做函数默认参数">9 Python是否能以可变对象做函数默认参数</a></li>
<li><a href="#10-企图在函数中修改全局变量,没有使用global,而创建了本地变量">10 企图在函数中修改全局变量,没有使用global,而创建了本地变量</a></li>
<li><a href="#11-对象的dir属性和dict属性">11 对象的dir属性和dict属性</a></li>
<li><a href="#12-staticmethod和classmethod">12 @staticmethod和@classmethod</a></li>
<li><a href="#13-使用property创建可管理的对象属性">13 使用property创建可管理的对象属性</a></li>
<li><a href="#14-类属性和实例属性">14 类属性和实例属性</a></li>
<li><a href="#15-python自省">15 Python自省</a></li>
<li><a href="#16-字典解析、列表解析、集合解析">16 字典解析、列表解析、集合解析</a></li>
<li><a href="#17-python中单下划线和双下划线">17 Python中单下划线和双下划线</a></li>
<li><a href="#18-字符串格式化和format">18 字符串格式化:\x和.format</a></li>
<li><a href="#19-正则表达式相关知识及字符串操作">19 正则表达式相关知识及字符串操作</a></li>
<li><a href="#20-迭代器和生成器">20 迭代器和生成器</a></li>
<li><a href="#21-args-and-kwargs">21 *args and <code>**kwargs</code></a></li>
<li><a href="#22-装饰器">22 装饰器</a></li>
<li><a href="#23-python中重载">23 Python中重载</a></li>
<li><a href="#24-__new__和__init__的区别">24 <strong>new</strong>和<code><strong>init</strong></code>的区别</a></li>
<li><a href="#25-单例模式">25 单例模式</a><ul>
<li><a href="#1-使用__new__方法">1 使用<strong>new</strong>方法</a></li>
<li><a href="#2-共享属性">2 共享属性</a></li>
<li><a href="#3-装饰器版本">3 装饰器版本</a></li>
<li><a href="#4-import方法">4 import方法</a></li>
</ul>
</li>
<li><a href="#26-python中的作用域">26 Python中的作用域</a></li>
<li><a href="#27-gil线程全局锁">27 GIL线程全局锁</a></li>
<li><a href="#28-协程">28 协程</a></li>
<li><a href="#29-闭包">29 闭包</a></li>
<li><a href="#30-lambda函数">30 lambda函数</a></li>
<li><a href="#31-python函数式编程">31 Python函数式编程</a></li>
<li><a href="#32-python里的拷贝">32 Python里的拷贝</a></li>
<li><a href="#33-Python是如何进行内存管理的">33 Python是如何进行内存管理的</a><ul>
<li><a href="#1-对象的引用计数机制">1 对象的引用计数机制</a></li>
<li><a href="#2-垃圾回收">2 垃圾回收</a></li>
<li><a href="#3-内存池机制">3 内存池机制</a></li>
</ul>
</li>
<li><a href="#34-Python的List和Dict的实现原理">34 Python的List和Dict的实现原理</a></li>
<li><a href="#35-python的is">35 Python的is</a></li>
<li><a href="#36-readreadline和readlines">36 read,readline和readlines</a></li>
<li><a href="#37-python2和3的区别">37 Python2和3的区别</a></li>
<li><a href="#38-Python的编码问题">38 Python的编码问题</a></li>
</ul>
</li>
<li><p><a href="#数据库">数据库</a></p>
<ul>
<li><a href="#1-事务">1 事务</a></li>
<li><a href="#2-数据库索引">2 数据库索引</a></li>
<li><a href="#3-redis原理">3 Redis原理</a><ul>
<li><a href="#redis是什么">Redis是什么？</a></li>
<li><a href="#redis数据库">Redis数据库</a></li>
<li><a href="#redis缺点">Redis缺点</a></li>
</ul>
</li>
<li><a href="#4-myisam和innodb">4 MyISAM和InnoDB</a></li>
</ul>
</li>
<li><a href="#网络">网络</a><ul>
<li><a href="#1-三次握手">1 三次握手</a></li>
<li><a href="#2-四次挥手">2 四次挥手</a></li>
<li><a href="#3-arp协议">3 ARP协议</a></li>
<li><a href="#4-urllib和urllib2的区别">4 urllib和urllib2的区别</a></li>
<li><a href="#5-post和get">5 Post和Get</a></li>
<li><a href="#6-cookie和session">6 Cookie和Session</a></li>
<li><a href="#7-apache和nginx的区别">7 apache和nginx的区别</a></li>
<li><a href="#8-网站用户密码保存">8 网站用户密码保存</a></li>
<li><a href="#9-http和https">9 HTTP和HTTPS</a></li>
<li><a href="#10-xsrf和xss">10 XSRF和XSS</a></li>
<li><a href="#12-restful架构soaprpc">12 RESTful架构(SOAP,RPC)</a></li>
<li><a href="#15-cgi和wsgi">15 CGI和WSGI</a></li>
<li><a href="#18-socket">18 socket</a></li>
<li><a href="#19-浏览器缓存">19 浏览器缓存</a></li>
<li><a href="#20-http10和http11">20 HTTP1.0和HTTP1.1</a></li>
<li><a href="#21-ajax">21 Ajax</a></li>
</ul>
</li>
<li><a href="#编程题">编程题</a><ul>
<li><a href="#1-列表复制问题">1 列表复制问题</a></li>
<li><a href="#2-求列表第三大的那个值">2 求列表第三大的那个值</a></li>
<li><a href="#3-实现一个队列">3 实现一个队列</a></li>
<li><a href="#4-实现一个堆栈">4 实现一个堆栈</a></li>
<li><a href="#5-用Python实现一个单向链表">5 用Python实现一个单向链表</a></li>
<li><a href="#6-用Python实现一个双向链表">6 用Python实现一个双向链表 </a></li>
<li><a href="#7-台阶问题斐波那契">7 台阶问题/斐波那契</a></li>
<li><a href="#8-变态台阶问题">8 变态台阶问题</a></li>
<li><a href="#9-去除列表中的重复元素">9 去除列表中的重复元素</a></li>
<li><a href="#10-创建字典的方法">10 创建字典的方法</a><ul>
<li><a href="#1-直接创建">1 直接创建</a></li>
<li><a href="#2-工厂方法">2 工厂方法</a></li>
<li><a href="#3-fromkeys方法">3 fromkeys()方法</a></li>
</ul>
</li>
<li><a href="#11-合并两个有序列表">11 合并两个有序列表</a></li>
<li><a href="#12-归并排序">12 归并排序</a></li>
<li><a href="#13-质数和日期问题">13 质数和日期问题</a></li>
<li><a href="#14-二分查找">14 二分查找</a></li>
<li><a href="#15-打印文件夹">15 打印文件夹</a></li>
<li><a href="#16-找零问题">16 找零问题</a></li>
<li><a href="#17-前中后序遍历">17 前中后序遍历</a></li>
<li><a href="#18-求最大树深">18 求最大树深</a></li>
<li><a href="#19-求两棵树是否相同">19 求两棵树是否相同</a></li>
<li><a href="#20-前序中序求后序">20 前序中序求后序</a></li>
<li><a href="#21-广度遍历和深度遍历二叉树">21 广度遍历和深度遍历二叉树</a></li>
<li><a href="#22-快排">22 快排</a></li>
<li><a href="#23-层次遍历">23 层次遍历</a></li>
<li><a href="#24-深度遍历">24 深度遍历</a></li>
</ul>
</li>
</ul>
<!-- markdown-toc end -->
<h1 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h1><h2 id="1-对Python的理解-对比其他语言"><a href="#1-对Python的理解-对比其他语言" class="headerlink" title="1 对Python的理解(对比其他语言)"></a>1 对Python的理解(对比其他语言)</h2><p>下面是一些关键点：</p>
<ul>
<li>Python是一种解释型语言。这就是说，与C语言和C的衍生语言不同，Python代码在运行之前不需要编译。</li>
<li>Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。</li>
<li>Python非常适合面向对象的编程（OOP），因为它支持通过组合（composition）与继承（inheritance）的方式定义类（class）。</li>
<li>Python中没有访问说明符（access specifier，类似C++中的public和private），这么设计的依据是“大家都是成年人了”。</li>
</ul>
<p>在Python语言中，函数是第一类对象（first-class objects）。这指的是它们可以被指定给变量，函数既能返回函数类型，也可以接受函数作为输入。类（class）也是第一类对象。<br>Python代码编写快，但是运行速度比编译语言通常要慢。好在Python允许加入基于C语言编写的扩展，因此我们能够优化代码，消除瓶颈，这点通常是可以实现的。numpy就是一个很好地例子，它的运行速度真的非常快，因为很多算术运算其实并不是通过Python实现的。</p>
<p>Python用途非常广泛——网络应用，自动化，科学建模，大数据应用，等等。它也常被用作“胶水语言”，帮助其他语言和组件改善运行状况。<br>Python让困难的事情变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>Python彩蛋</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"></span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> __hello__</span><br><span class="line"></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<h2 id="2-什么是Python的命名空间"><a href="#2-什么是Python的命名空间" class="headerlink" title="2 什么是Python的命名空间"></a>2 什么是Python的命名空间</h2><p>在Python中，所有的名字都存在于一个空间中，它们在该空间中存在和被操作——这就是命名空间。</p>
<p>它就好像一个盒子，每一个变量名字都对应装着一个对象。当查询变量的时候，会从该盒子里面寻找相应的对象。</p>
<h2 id="3-Python中的pass语句"><a href="#3-Python中的pass语句" class="headerlink" title="3 Python中的pass语句"></a>3 Python中的pass语句</h2><p>Pass是一个在Python中不会被执行的语句。在复杂语句中，如果一个地方需要暂时被留白，它常常被用于占位符。</p>
<h2 id="4-Python异常处理的用法和作用"><a href="#4-Python异常处理的用法和作用" class="headerlink" title="4　Python异常处理的用法和作用"></a>4　Python异常处理的用法和作用</h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191375461417a222c54b7e4d65b258f491c093a515000]
答：try…except…except…[else…][finally…" target="_blank" rel="noopener">参考廖雪峰</a></p>
<ul>
<li><p>执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。</p>
</li>
<li><p>如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。</p>
</li>
<li><p>try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行</p>
</li>
<li><p>如果存在finally语句，最后总是会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / int(&apos;2&apos;)</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError:&apos;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;ZeroDivisionError:&apos;, e)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;no error!&apos;)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-Python的函数参数传递"><a href="#5-Python的函数参数传递" class="headerlink" title="5 Python的函数参数传递"></a>5 Python的函数参数传递</h2><p>看两个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>所有的变量都可以理解是内存中一个对象的“引用”</p>
<p>通过<code>id</code>来看引用<code>a</code>的内存地址可以比较理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_in"</span>,id(a)   <span class="comment"># func_in 41322472</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"re-point"</span>,id(a), id(<span class="number">2</span>)   <span class="comment"># re-point 41322448 41322448</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"func_out"</span>,id(a), id(<span class="number">1</span>)  <span class="comment"># func_out 41322472 41322472</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>注：具体的值在不同电脑上运行时可能不同。</p>
<p>可以看到，在执行完<code>a = 2</code>之后，<code>a</code>引用中保存的值，即内存地址发生变化，由原来<code>1</code>对象的所在的地址变成了<code>2</code>这个实体对象的内存地址。</p>
<p>而第2个例子<code>a</code>引用保存的内存值就不会发生变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"func_in"</span>,id(a)  <span class="comment"># func_in 53629256</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"func_out"</span>,id(a)     <span class="comment"># func_out 53629256</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可变”（mutable）与“不可变”（immutable）对象。在python中，string, tuple, 和number是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)</p>
<p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p>
<p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="noopener">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<h2 id="6-函数的参数用法和注意事项"><a href="#6-函数的参数用法和注意事项" class="headerlink" title="6 函数的参数用法和注意事项"></a>6 函数的参数用法和注意事项</h2><p>(参考廖雪峰课程)[<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000]" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000]</a><br>函数参数分为位置参数、默认参数、可变参数、关键字参数、命名关键字参数（定义和调用必须按顺序传入）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">numbers=[1,2,3,4,5]</span><br><span class="line">def sum(*args):</span><br><span class="line">    sum=0</span><br><span class="line">    for i in args:</span><br><span class="line">        sum = sum+i*i</span><br><span class="line">    return sum  </span><br><span class="line">sum(*numbers)</span><br><span class="line"></span><br><span class="line">dict1=&#123;&apos;a&apos;:1,&apos;b&apos;:2&#125;</span><br><span class="line">def f(**kwargs):</span><br><span class="line">    for k,v in kwargs.items():</span><br><span class="line">        print(&apos;&#123;0&#125;:&#123;1&#125;&apos;.format(k,v))</span><br><span class="line">f(**dict1)</span><br><span class="line"></span><br><span class="line"># 如果需要约束传入的关键字参数的名称，可以用命名关键字参数</span><br><span class="line"># 命名关键字参数必须传入参数名，这和位置参数不同。</span><br><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"></span><br><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br><span class="line"></span><br><span class="line"># 命名关键字参数可以有缺省值，从而简化调用：</span><br><span class="line">def person(name, age, *, city=&apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure></p>
<h2 id="7-可变对象和不可变对象"><a href="#7-可变对象和不可变对象" class="headerlink" title="7 可变对象和不可变对象"></a>7 可变对象和不可变对象</h2><ul>
<li>python所有数字类型(布尔树,整数,浮点数,复数)均为不可变对象,</li>
<li>可变对象:file,dict,set,list,bytesarray,range</li>
<li>不可变对象:boolean,int,float,complex,tuple,str,bytes,frozenset</li>
<li>有序sequence:str,list,tuple,OrderedDict,</li>
<li>无序:dict,set,</li>
<li>不可重复:set,tuple</li>
<li>可变对象(mutable object)has no hash value</li>
<li>不可变对象可哈希,hashable</li>
</ul>
<h2 id="8-def是运行时执行语句-并且是赋值语句"><a href="#8-def是运行时执行语句-并且是赋值语句" class="headerlink" title="8 def是运行时执行语句,并且是赋值语句"></a>8 def是运行时执行语句,并且是赋值语句</h2><p>类和对象均为第一类对象，调用的时候才会运行</p>
<h2 id="9-Python是否能以可变对象做函数默认参数"><a href="#9-Python是否能以可变对象做函数默认参数" class="headerlink" title="9 Python是否能以可变对象做函数默认参数"></a>9 Python是否能以可变对象做函数默认参数</h2><p>不可以,字典,集合,列表等可变对象不适合作为函数默认值<br>要不然第二次调用时,一次调用的默认参数的值会影响二次调用.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def f(l=[]):</span><br><span class="line">    for i in range(3):</span><br><span class="line">        l.append(i)</span><br><span class="line">    return l</span><br><span class="line">f(l=[2]),---- l=[2,0,1,2]</span><br><span class="line">f(),     ---- l=[0,1,2]</span><br><span class="line">f(),     ---- l=[0,1,2,0,1,2]</span><br></pre></td></tr></table></figure></p>
<h2 id="10-企图在函数中修改全局变量-没有使用global-而创建了本地变量"><a href="#10-企图在函数中修改全局变量-没有使用global-而创建了本地变量" class="headerlink" title="10 企图在函数中修改全局变量,没有使用global,而创建了本地变量"></a>10 企图在函数中修改全局变量,没有使用global,而创建了本地变量</h2><p>修改全局变量需要global声明,要不然会创建同名的本地变量.</p>
<h2 id="11-对象的dir属性和dict属性"><a href="#11-对象的dir属性和dict属性" class="headerlink" title="11 对象的dir属性和dict属性"></a>11 对象的dir属性和dict属性</h2><p>Python一切皆对象，每个对象都有自己独特的属性和方法<br>dir()函数会自动寻找一个对象的所有属性，包括dict中的属性。<br>dict是dir()的子集，dir()包含dict中的属性。</p>
<h2 id="12-staticmethod和-classmethod"><a href="#12-staticmethod和-classmethod" class="headerlink" title="12 @staticmethod和@classmethod"></a>12 @staticmethod和@classmethod</h2><p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure>
<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
<table>
<thead>
<tr>
<th style="text-align:left">\</th>
<th style="text-align:left">实例方法</th>
<th style="text-align:left">类方法</th>
<th style="text-align:left">静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = A()</td>
<td style="text-align:left">a.foo(x)</td>
<td style="text-align:left">a.class_foo(x)</td>
<td style="text-align:left">a.static_foo(x)</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">不可用</td>
<td style="text-align:left">A.class_foo(x)</td>
<td style="text-align:left">A.static_foo(x)</td>
</tr>
</tbody>
</table>
<p>更多关于这个问题:</p>
<ol>
<li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li>
<li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></li>
</ol>
<h2 id="13-使用property创建可管理的对象属性"><a href="#13-使用property创建可管理的对象属性" class="headerlink" title="13 使用property创建可管理的对象属性"></a>13 使用property创建可管理的对象属性</h2><p>property可以让实例在形式上是属性访问,但实际上调用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Circle2(object):</span><br><span class="line">    def __init__(self, radius):</span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line">    def getRadius(self):</span><br><span class="line">        # return self.radius</span><br><span class="line">        return round(self.radius, 2)  # 表示四舍五入后保留小数点后两位</span><br><span class="line"></span><br><span class="line">    def setRadius(self, value):</span><br><span class="line">        if not isinstance(value, (int, long, float)):</span><br><span class="line">            raise valueError(&apos;wrong type .&apos;)</span><br><span class="line">        self.radius = float(value)</span><br><span class="line"></span><br><span class="line">    def getArea(self):</span><br><span class="line">        return self.radius * 2 * pi</span><br><span class="line"></span><br><span class="line">    R = property(getRadius, setRadius)</span><br><span class="line"></span><br><span class="line">r = Circle2(3.2)</span><br><span class="line">print(r.R)  # 自动调用getRadius</span><br><span class="line">r.R = 5.4  # 自动调用setRadius</span><br><span class="line">print(r.R)  # 自动调用getRadius</span><br></pre></td></tr></table></figure></p>
<h2 id="14-类属性和实例属性"><a href="#14-类属性和实例属性" class="headerlink" title="14 类属性和实例属性"></a>14 类属性和实例属性</h2><p><strong>：</strong></p>
<blockquote>
<p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类属性，用于跟踪存在着多少个Test 的实例。</p>
</blockquote>
<p><strong>实例属性：</strong></p>
<blockquote>
<p>实例化之后，每个实例单独拥有的变量。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">'jack'</span>)  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">'lucy'</span>)  </span><br><span class="line">    <span class="keyword">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="keyword">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure>
<p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类属性,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类属性<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类属性的引用改变了,就变成了一个实例属性,self.name不再引用Person的类属性name了.</p>
<p>可以看看下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>
<h2 id="15-Python自省"><a href="#15-Python自省" class="headerlink" title="15 Python自省"></a>15 Python自省</h2><p>这个也是python彪悍的特性.</p>
<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">c = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">print</span> type(a),type(b),type(c) <span class="comment"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class="line"><span class="keyword">print</span> isinstance(a,list)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h2 id="16-字典解析、列表解析、集合解析"><a href="#16-字典解析、列表解析、集合解析" class="headerlink" title="16 字典解析、列表解析、集合解析"></a>16 字典解析、列表解析、集合解析</h2><p>代码示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">list1=[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>) <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>] <span class="comment">#或 [x for x in range(0,100,2)]</span></span><br><span class="line">L = list(map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">L2 = list(filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>, [<span class="number">1.</span> - <span class="number">1</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">34</span>]))</span><br><span class="line"><span class="comment">#集合的列表生成式</span></span><br><span class="line">s=&#123;<span class="number">1</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">-7</span>,<span class="number">6</span>,<span class="number">87</span>,<span class="number">-8</span>,<span class="number">-9</span>,<span class="number">11</span>&#125;</span><br><span class="line">print(&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> x%<span class="number">3</span>==<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">#补充：集合的交集并集等操作</span></span><br><span class="line">A=set([randint(<span class="number">1</span>,<span class="number">20</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">B=set([randint(<span class="number">1</span>,<span class="number">20</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">print(A&amp;B,A|B,A-B,A^B) <span class="comment">#交，并，差，补</span></span><br><span class="line"></span><br><span class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable <span class="keyword">if</span> key**&#125;</span><br><span class="line"><span class="comment">#补充 如何根据字典中值的大小,对字典中的项排序</span></span><br><span class="line"><span class="comment">#方案1 使用zip将字典数据转化为元组</span></span><br><span class="line">score = &#123;</span><br><span class="line">    <span class="string">'LiLei'</span>: <span class="number">79</span>,</span><br><span class="line">    <span class="string">'Jim'</span>: <span class="number">88</span>,</span><br><span class="line">    <span class="string">'Lucy'</span>: <span class="number">92</span></span><br><span class="line">&#125;</span><br><span class="line">score4 = tuple(zip(score.values(),score.keys()))</span><br><span class="line">score5 = sorted(score4)</span><br><span class="line"><span class="comment">##直接用sorted,</span></span><br><span class="line">print(sorted(score.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])) <span class="comment">#表示对生成的列表的元组索引第二位进行排序</span></span><br><span class="line"><span class="comment">#补充 k,v交换</span></span><br><span class="line">score2=&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> score.items()&#125;</span><br><span class="line">score3=dict(zip(score2.values(),score2.keys()))</span><br></pre></td></tr></table></figure>
<h4 id="补充1-如何为元组的每个元素命名-提高程序可读性"><a href="#补充1-如何为元组的每个元素命名-提高程序可读性" class="headerlink" title="补充1 如何为元组的每个元素命名,提高程序可读性"></a>补充1 如何为元组的每个元素命名,提高程序可读性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from collections import namedtuple</span><br><span class="line">Student = namedtuple(&apos;Student&apos;, [&apos;name&apos;, &apos;age&apos;, &apos;sex&apos;, &apos;email&apos;])</span><br><span class="line">Jim = Student(&apos;Jim&apos;, 16, &apos;male&apos;, &apos;jim8721@gamil.com&apos;)</span><br><span class="line">print(Jim.name)</span><br><span class="line">print(Jim.age)</span><br><span class="line">print(Jim.sex)</span><br><span class="line">print(Jim.email)</span><br></pre></td></tr></table></figure>
<h4 id="补充2-如何统计序列中元素的出现频度"><a href="#补充2-如何统计序列中元素的出现频度" class="headerlink" title="补充2 如何统计序列中元素的出现频度"></a>补充2 如何统计序列中元素的出现频度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter, OrderedDict</span><br><span class="line">from random import randint</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">data = [randint(0, 20) for _ in range(30)] #产生30个0到20的随机整数</span><br><span class="line">print(Counter(data))</span><br><span class="line">print(Counter(data).most_common(3))</span><br></pre></td></tr></table></figure>
<h4 id="补充3-如何快速找到多个字典中的公共键-key"><a href="#补充3-如何快速找到多个字典中的公共键-key" class="headerlink" title="补充3 如何快速找到多个字典中的公共键(key)"></a>补充3 如何快速找到多个字典中的公共键(key)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">N1 = &#123;</span><br><span class="line">    &apos;苏亚雷斯&apos;: 1,</span><br><span class="line">    &apos;梅西&apos;: 2,</span><br><span class="line">    &apos;本泽马&apos;: 1,</span><br><span class="line">    &apos;C罗&apos;: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">N2 = &#123;</span><br><span class="line">    &apos;苏亚雷斯&apos;: 2,</span><br><span class="line">    &apos;C罗&apos;: 1,</span><br><span class="line">    &apos;格里子曼&apos;: 2,</span><br><span class="line">    &apos;贝尔&apos;: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">N3 = &#123;</span><br><span class="line">    &apos;苏亚雷斯&apos;: 1,</span><br><span class="line">    &apos;托雷斯&apos;: 2,</span><br><span class="line">    &apos;内马尔&apos;: 1,</span><br><span class="line">    &apos;贝尔&apos;: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 统计出每轮比赛都有进球的球员</span><br><span class="line">res = []</span><br><span class="line">for k in N1:</span><br><span class="line">    if k in N2 and k in N3:</span><br><span class="line">        res.append(k)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">#解决方案:</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">利用set集合的交集操作</span><br><span class="line">1.使用dict的viewkeys()方法,返回一个dict.keys()的集合</span><br><span class="line">2.使用map函数,得到所有字典的keys的集合</span><br><span class="line">3.使用reduce函数,取所有字典的keys的集合的交集</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">print(reduce(lambda x,y:x &amp;y,list(map(dict.keys,[N1,N2,N3]))))</span><br></pre></td></tr></table></figure>
<h4 id="补充4-创建有序的字典"><a href="#补充4-创建有序的字典" class="headerlink" title="补充4 创建有序的字典"></a>补充4 创建有序的字典</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from functools import OrderedDict</span><br><span class="line">od = OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])</span><br><span class="line"># 字典输出可以按插入的顺序排序并输出</span><br></pre></td></tr></table></figure>
<h4 id="补充5-元组和列表的同异"><a href="#补充5-元组和列表的同异" class="headerlink" title="补充5 元组和列表的同异"></a>补充5 元组和列表的同异</h4><p>同：列表与元组都是容器，是一系列的对象。二者都可以包含任意类型的元素甚至可以是一个序列，还可以包含元素的顺序（不像集合和字典）。<br>元组属于不可变对象，列表属于可变对象，列表的很多方法不适用于元组；元组可哈希而列表不可哈希；元组占用空间更小，代码的语义更好理解再函数式编程较常用。</p>
<h2 id="17-Python中单下划线和双下划线"><a href="#17-Python中单下划线和双下划线" class="headerlink" title="17 Python中单下划线和双下划线"></a>17 Python中单下划线和双下划线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p>
<p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p>
<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.</p>
<p>详情见:<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>
<p>或者: <a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p>
<h2 id="18-字符串格式化-和-format"><a href="#18-字符串格式化-和-format" class="headerlink" title="18 字符串格式化:%和.format"></a>18 字符串格式化:%和.format</h2><p>.format在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % name</span><br></pre></td></tr></table></figure>
<p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></table></figure>
<p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.</p>
<p>你为什么不用它?</p>
<ul>
<li>不知道它(在读这个之前)</li>
<li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4" target="_blank" rel="noopener">issue #4</a>))</li>
</ul>
<p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="noopener">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p>
<h2 id="19-正则表达式相关知识及字符串操作"><a href="#19-正则表达式相关知识及字符串操作" class="headerlink" title="19 正则表达式相关知识及字符串操作"></a>19 正则表达式相关知识及字符串操作</h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000" target="_blank" rel="noopener">参考廖雪峰</a></p>
<ul>
<li><p>字符串拼接join方法<br>str.join(iterable)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [&quot;&lt;0112&gt;&quot;, &quot;&lt;32&gt;&quot;, &quot;&lt;1024x768&gt;&quot;, 60, &quot;&lt;1&gt;&quot;, &quot;&lt;100.0&gt;&quot;, &quot;&lt;500.0&gt;&quot;]</span><br><span class="line">print(&apos;&apos;.join(str(x) for x in L))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断字符串a是否以字符串b开头或结尾,str.startswith(),str.endswith()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=&quot;abcdefg||fadfa.py&quot;</span><br><span class="line">a.endswith((&apos;.py&apos;,&apos;.sh&apos;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何用Python来进行查询和替换一个文本字符串？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;\tabd\t124\txyz\r\n&apos;</span><br><span class="line">print(re.sub(&apos;\t|\r|\n&apos;,&apos;&apos;,s))</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次性拆分字符串 re.split(),str.split()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">解决方案:</span></span><br><span class="line"><span class="string">方法一:连续使用是str.split()方法,每次处理一种分隔符号</span></span><br><span class="line"><span class="string">方法二:使用正则表达式的re.split()方法,一次性拆分字符串</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = <span class="string">'ab;cd|efg|hi,jklmn|topq;rst,uvw|txyz'</span></span><br><span class="line">t = s.split(<span class="string">';'</span>)</span><br><span class="line">t1 = re.split(<span class="string">r'[,;|\t]+'</span>,s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Python里面match()和search()的区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。</span><br><span class="line">re模块中re.search(pattern,string[,flags]),在string搜索pattern的第一个匹配值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Python re.findall()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#寻找一段字符串中的11位数字（手机号），返回列表</span><br><span class="line">import re</span><br><span class="line">str1=&quot;13832244324gdsjsfhauer13632996133&quot;</span><br><span class="line">re.findall(r&apos;\d&#123;11&#125;&apos;,str1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用Python匹配HTML tag的时候，&lt;.<em>&gt;和&lt;.</em>?&gt;有什么区别？<br>答：术语叫贪婪匹配( &lt;.<em>&gt; )和非贪婪匹配(&lt;.</em>?&gt; )<br>前者是贪婪匹配，会从头到尾匹配 <a>xyz</a>，而后者是非贪婪匹配，只匹配到第一个 &gt;。</p>
</li>
</ul>
<ul>
<li>如何去掉字符串中不需要的字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">解决方案:</span><br><span class="line">方法1:字符串strip(),lstrip(),rstrip()方法去掉字符串两段字符</span><br><span class="line">方法2:删除单个固定位置的字符,可以使用切片+拼接的方式</span><br><span class="line">方法3:字符串的replace()方法或正则表达式re.sub()删除任意位置字符</span><br><span class="line">方法4:字符串translate()方法,可以同时删除多种不同字符</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">s=&apos;  nick2008@gmail.com  &apos;</span><br><span class="line">print(s.strip(&apos; &apos;))</span><br><span class="line">print(&apos;----------------&apos;)</span><br><span class="line">s = &apos;====+-----&apos;</span><br><span class="line">print(s.strip(&apos;-=&apos;))</span><br><span class="line">print(&apos;----------------&apos;)</span><br><span class="line">s=&apos;  nick2008  @gmail.com  &apos;</span><br><span class="line">print(s[2:11]+s[12:23])</span><br><span class="line">print(&apos;----------------&apos;)</span><br><span class="line"></span><br><span class="line">s = &apos;\tabd\t124\txyz\r\n&apos;</span><br><span class="line">print(s.replace(&apos;\t&apos;,&apos;&apos;))</span><br><span class="line">print(&apos;----------------&apos;)</span><br><span class="line">s = &apos;\tabd\t124\txyz\r\n&apos;</span><br><span class="line">print(re.sub(&apos;\t|\r|\n&apos;,&apos;&apos;,s))</span><br><span class="line">print(&apos;----------------&apos;)</span><br><span class="line">s = &apos;\tabd\t124\txyz\r\n&apos;</span><br><span class="line">print(s.translate(None,&apos;\t\r\n&apos;))</span><br><span class="line"></span><br><span class="line">s = &apos;\tabd\t124\txyz\r\n&apos;</span><br><span class="line">print(s.replace(&apos;\t&apos;,&apos;&apos;))</span><br><span class="line">u = u&apos;uulàlà,là,māmá&apos;</span><br><span class="line">print u.translate(dict.fromkeys([0x0,0x0101,0x1]))</span><br></pre></td></tr></table></figure>
<ul>
<li>补充 单引号，双引号，三引号的区别</li>
</ul>
<p>答：单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释</p>
<p>如果要表示Let’s go 这个字符串</p>
<p>单引号：s4 = ‘Let\’s go’</p>
<p>双引号：s5 = “Let’s go”</p>
<p>s6 = ‘I realy like“python”!’</p>
<p>这就是单引号和双引号都可以表示字符串的原因了</p>
<h2 id="20-迭代器和生成器"><a href="#20-迭代器和生成器" class="headerlink" title="20 迭代器和生成器"></a>20 迭代器和生成器</h2><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p>
<p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>
<p>这里有个关于生成器的创建问题面试官有考：<br>问：  将列表生成式中[]改成() 之后数据结构是否改变？<br>答案：是，从列表变为生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000028F8B774200</span>&gt;</span><br></pre></td></tr></table></figure>
<p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</p>
<p>###大数据的文件读取<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path,<span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure></p>
<p>###yield语句的用法<br>相当于给函数运行打断点，下次循环或者调用时在这里终止程序<br>yield简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次（或n 次）调用跳转至该函树）调用跳转至该函数。</p>
<h2 id="21-args-and-kwargs"><a href="#21-args-and-kwargs" class="headerlink" title="21 *args and **kwargs"></a>21 <code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p>
<p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> enumerate(args):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</span><br><span class="line"><span class="number">0.</span> apple</span><br><span class="line"><span class="number">1.</span> banana</span><br><span class="line"><span class="number">2.</span> cabbage</span><br></pre></td></tr></table></figure>
<p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure>
<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></table></figure>
<p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p>
<p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">'aardvark'</span>, <span class="string">'baboon'</span>, <span class="string">'cat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure>
<p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p>
<p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="noopener">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>
<h2 id="22-装饰器"><a href="#22-装饰器" class="headerlink" title="22 装饰器"></a>22 装饰器</h2><p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有计时统计、插入日志、缓存计算结果、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong><br>装饰器的作用和功能：</p>
<ul>
<li>引入日志</li>
<li>函数执行时间统计</li>
<li>执行函数前预备处理</li>
<li>执行函数后的清理功能</li>
<li>权限校验等场景</li>
<li>缓存</li>
</ul>
<p>下面举例说明</p>
<h4 id="装饰器用做日志记录"><a href="#装饰器用做日志记录" class="headerlink" title="装饰器用做日志记录"></a>装饰器用做日志记录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wrapper</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func) # 将func的属性传递给wrapper</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        f=func(*args, **kw)</span><br><span class="line">        print(<span class="string">'end call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> f    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<h4 id="如何定义带参数的装饰器"><a href="#如何定义带参数的装饰器" class="headerlink" title="如何定义带参数的装饰器"></a>如何定义带参数的装饰器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"># 同时支持@log和@log(&apos;execute&apos;)</span><br><span class="line">def log2(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            if isinstance(text,str):</span><br><span class="line">                print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            else:</span><br><span class="line">                print(&apos;%s():&apos; % func.__name__)</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    if callable(text):</span><br><span class="line">        return decorator(text)</span><br><span class="line">    else:</span><br><span class="line">        return decorator</span><br></pre></td></tr></table></figure>
<h4 id="装饰器用做执行时间统计"><a href="#装饰器用做执行时间统计" class="headerlink" title="装饰器用做执行时间统计"></a>装饰器用做执行时间统计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from functools import wrapper</span><br><span class="line">from time import time</span><br><span class="line">def metric(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        t0 = time()</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        print(&apos;%s executed in %s ms&apos; % (func.__name__, (time() - t0) * 1000))</span><br><span class="line">        return func</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<h4 id="装饰器用做缓存"><a href="#装饰器用做缓存" class="headerlink" title="装饰器用做缓存"></a>装饰器用做缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def meomo(func):</span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    def wrap(*args):</span><br><span class="line">        if args not in cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        return cache[args]</span><br><span class="line">    return wrap</span><br><span class="line">@meomo</span><br><span class="line">def fibonacci(n):</span><br><span class="line">    if n&lt;=1:</span><br><span class="line">        return 1</span><br><span class="line">    cache = fibonacci(n-1)+fibonacci(n-2)</span><br><span class="line">    return cache</span><br><span class="line">&quot;&quot;&quot;一个共有十个10个台阶的楼梯,从下面走到上面,一次只能迈1-3个台阶,</span><br><span class="line">并且不能后退,走完这个楼梯共有多少种方法&quot;&quot;&quot;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">@meomo</span><br><span class="line">def climb(n,steps):</span><br><span class="line">    count = 0</span><br><span class="line">    if n == 0:</span><br><span class="line">        count +=1</span><br><span class="line">    elif n&gt;0:</span><br><span class="line">        for step in steps:</span><br><span class="line">            count += climb(n-step,steps)</span><br><span class="line">    return count</span><br></pre></td></tr></table></figure>
<p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p>
<p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="noopener">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p>
<h2 id="23-Python中重载"><a href="#23-Python中重载" class="headerlink" title="23 Python中重载"></a>23 Python中重载</h2><p>引自知乎:<a href="http://www.zhihu.com/question/20053359" target="_blank" rel="noopener">http://www.zhihu.com/question/20053359</a></p>
<p>函数重载主要是为了解决两个问题。</p>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。</li>
</ol>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>
<h2 id="24-new-和-init-的区别"><a href="#24-new-和-init-的区别" class="headerlink" title="24 __new__和__init__的区别"></a>24 <code>__new__</code>和<code>__init__</code>的区别</h2><p>这个<code>__new__</code>确实很少见到,先做了解吧.</p>
<ol>
<li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li>
</ol>
<p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init" target="_blank" rel="noopener">stackoverflow</a></p>
<p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p>
<h2 id="25-单例模式"><a href="#25-单例模式" class="headerlink" title="25 单例模式"></a>25 单例模式</h2><blockquote>
<p>​    单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p>
</blockquote>
<h3 id="1-使用-new-方法"><a href="#1-使用-new-方法" class="headerlink" title="1 使用__new__方法"></a>1 使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-共享属性"><a href="#2-共享属性" class="headerlink" title="2 共享属性"></a>2 共享属性</h3><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="4-import方法"><a href="#4-import方法" class="headerlink" title="4 import方法"></a>4 import方法</h3><p>作为python的模块是天然的单例模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure>
<p><strong><a href="http://python.jobbole.com/87294/" target="_blank" rel="noopener">单例模式伯乐在线详细解释</a></strong></p>
<h2 id="26-Python中的作用域"><a href="#26-Python中的作用域" class="headerlink" title="26 Python中的作用域"></a>26 Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>
<p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p>
<p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p>
<h2 id="27-GIL线程全局锁"><a href="#27-GIL线程全局锁" class="headerlink" title="27 GIL线程全局锁"></a>27 GIL线程全局锁</h2><p> Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。线程的执行速度非常之快，会让你误以为线程是并行执行的（并行），但是实际上都是轮流执行（并发或者串行）。<strong>对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</strong><br> 在多线程环境中，Python 虚拟机按以下方式执行：</p>
<ol>
<li>设置GIL</li>
<li>切换到一个线程去运行</li>
<li>运行：<br> a. 指定数量的字节码指令，或者<br> b. 线程主动让出控制（可以调用time.sleep(0)）</li>
<li>把线程设置为睡眠状态</li>
<li>解锁GIL</li>
<li>再次重复以上所有步骤<br>在调用外部代码（如C/C++扩展函数）的时候，GIL 将会被锁定，直到这个函数结束为止（由于在这期间没有Python 的字节码被运行，所以不会做线程切换）。<br>join方法 子进程结束切换到父进程<br>多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。</li>
</ol>
<p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="noopener">Python 最难的问题</a></p>
<p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p>
<h2 id="28-协程"><a href="#28-协程" class="headerlink" title="28 协程"></a>28 协程</h2><h3 id="参考廖雪峰"><a href="#参考廖雪峰" class="headerlink" title="参考廖雪峰"></a><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000" target="_blank" rel="noopener">参考廖雪峰</a></h3><p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p>
<p>Python对协程的支持是通过generator实现的。</p>
<h2 id="29-闭包"><a href="#29-闭包" class="headerlink" title="29 闭包"></a>29 闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>
<p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p>
<p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类属性,只不过迁移到了函数上.</p>
<p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p>
<h2 id="30-lambda函数"><a href="#30-lambda函数" class="headerlink" title="30 lambda函数"></a>30 lambda函数</h2><p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p>
<p>推荐: <a href="http://www.zhihu.com/question/20125256" target="_blank" rel="noopener">知乎</a></p>
<h2 id="31-Python函数式编程"><a href="#31-Python函数式编程" class="headerlink" title="31 Python函数式编程"></a>31 Python函数式编程</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p>
<p>推荐: <a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="noopener">酷壳</a></p>
<p>python中函数式编程支持:</p>
<p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;b = filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>filter函数用于对序列的每个项进行迭代，不满足条件的就会被踢出序列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x&gt;<span class="number">0</span>:x,range(<span class="number">-10</span>,<span class="number">4</span>))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<p>补充：用filter求素数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def _odd_iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0</span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _odd_iter() # 初始序列</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it) # 返回序列的第一个数</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it) # 构造新序列</span><br><span class="line"># 打印1000以内的素数:</span><br><span class="line">for n in primes():</span><br><span class="line">    if n &lt; 1000:</span><br><span class="line">        print(n)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p>
<h2 id="32-Python里的拷贝"><a href="#32-Python里的拷贝" class="headerlink" title="32 Python里的拷贝"></a>32 Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>
<p>切片的对象，切片是浅拷贝还是深拷贝<br>切片的对象有list,tuple,str<br>“=”,copy,slice属于浅拷贝<br>deepcopy就属于深拷贝<br>浅拷贝和深拷贝的区别在于深拷贝是被复制的对象作为一个新的个体独立存在,<br>任意改变其一不会对另一个对象造成影响,而浅拷贝不会产生新的独立对象</p>
<h2 id="33-Python是如何进行内存管理的"><a href="#33-Python是如何进行内存管理的" class="headerlink" title="33 Python是如何进行内存管理的"></a>33 Python是如何进行内存管理的</h2><p>(<a href="http://developer.51cto.com/art/201007/213585.html" target="_blank" rel="noopener">http://developer.51cto.com/art/201007/213585.html</a>)</p>
<p>答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制</p>
<ul>
<li>1、对象的引用计数机制</li>
</ul>
<p>Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。</p>
<p>引用计数增加的情况：</p>
<p>1，一个对象分配一个新名称</p>
<p>2，将其放入一个容器中（如列表、元组或字典）</p>
<p>引用计数减少的情况：</p>
<p>1，使用del语句对对象别名显示的销毁</p>
<p>2，引用超出作用域或被重新赋值</p>
<p>sys.getrefcount( )函数可以获得对象的当前引用计数</p>
<p>多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。</p>
<ul>
<li>2、垃圾回收</li>
</ul>
<p>1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</p>
<p>2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，</p>
<p>因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。</p>
<ul>
<li>3、内存池机制</li>
</ul>
<p>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。</p>
<p>1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。</p>
<p>2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。</p>
<p>3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。</p>
<h2 id="34-Python的List和Dict的实现原理"><a href="#34-Python的List和Dict的实现原理" class="headerlink" title="34 Python的List和Dict的实现原理"></a>34 Python的List和Dict的实现原理</h2><p>推荐:<br><a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="noopener">列表</a><br><a href="https://blog.csdn.net/shouting3901/article/details/80468735" target="_blank" rel="noopener">字典</a></p>
<ul>
<li>字典按照键值对的形式进行存储，时间复杂度为O(1)</li>
<li>字典的底层是通过哈希表实现的，使用开放地址法解决冲突。所以其查找的时间复杂度会是O(1)，哈希函数求哈希值</li>
</ul>
<h2 id="35-Python的is和"><a href="#35-Python的is和" class="headerlink" title="35 Python的is和=="></a>35 Python的is和==</h2><p>is是对比地址,==是对比值<br>is 比较的是两个实例对象是不是完全相同,is关键字是查看两个对象是否相同的唯一标准，他们是不是同一个对象,<br>占用的内存地址是否相同,即比较他们的id<br>== 比较的是两个实例对象的内容是否相同,即他们的内存地址可以不同,默认调用eq方法<br>切片slice is-&gt;False ==-&gt;True<br>序列直接复制=  is-&gt;True<br>大量创建相同内容的字符串，is-&gt;True<br>小整数对象[-5,256]在全局解释器范围内被放入缓存共重复使用<br>a=1 b=1 a is b -&gt;True ==-&gt;True<br>a=257 b=257 a is b -&gt;True ==-&gt;True</p>
<p>is运算符比==效率高,在变量和None进行比较时,应该使用is</p>
<h2 id="36-read-readline和readlines"><a href="#36-read-readline和readlines" class="headerlink" title="36 read,readline和readlines"></a>36 read,readline和readlines</h2><ul>
<li>read        读取整个文件</li>
<li>readline    读取下一行,使用生成器方法</li>
<li>readlines   读取整个文件到一个迭代器以供我们遍历</li>
</ul>
<h2 id="37-Python2和3的区别"><a href="#37-Python2和3的区别" class="headerlink" title="37 Python2和3的区别"></a>37 Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" target="_blank" rel="noopener">Python 2.7.x 与 Python 3.x 的主要差异</a></p>
<h4 id="补充：Python的编码问题"><a href="#补充：Python的编码问题" class="headerlink" title="补充：Python的编码问题"></a>补充：Python的编码问题</h4><p>python3 bytes和str都可以代表字符序列,前者的实例包含原始的8位值;bytes.decode(‘utf-8’)<br>后者的实例包含unicode字符 str.encode(‘utf-8’)</p>
<p>python2 str和Unicode都可以代表字符序列,与python3不同的是,str的实例包含原始的8位值,str.decode(‘utf-8’)<br>而Unicode的实例则包含unicode字符,unicode.encode(‘utf-8’)</p>
<p>python2 str <--> python3 bytes<br>python2 unicode <--> python3 str</--></--></p>
<p>python2 str.decode(‘utf-8’)–&gt;unicode<br>unicode.encode(‘utf-8’)–&gt;str<br>python3 bytes.decode(‘utf-8’)–&gt;str<br>str.encode(‘utf-8’) –&gt;bytes</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h2><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p>
<h2 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2 数据库索引"></a>2 数据库索引</h2><p>推荐: <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">http://tech.meituan.com/mysql-index.html</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
<p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p>
<h2 id="3-Redis原理"><a href="#3-Redis原理" class="headerlink" title="3 Redis原理"></a>3 Redis原理</h2><h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><ol>
<li>是一个完全开源免费的key-value内存数据库</li>
<li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li>
</ol>
<h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><blockquote>
<p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作</p>
</blockquote>
<ul>
<li>速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万</li>
<li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof)</li>
<li>自动操作：对不同数据类型的操作都是自动的，很安全</li>
<li>快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。</li>
<li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li>
</ul>
<h3 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h3><ul>
<li>是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="4-MyISAM和InnoDB"><a href="#4-MyISAM和InnoDB" class="headerlink" title="4 MyISAM和InnoDB"></a>4 MyISAM和InnoDB</h2><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h2><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li>
<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li>
</ol>
<h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2 四次挥手"></a>2 四次挥手</h2><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p>
<ol>
<li>客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.</li>
<li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.</li>
<li>服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.</li>
<li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.</li>
</ol>
<p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p>
<h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3 ARP协议"></a>3 ARP协议</h2><p>地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p>
<h2 id="4-urllib和urllib2的区别"><a href="#4-urllib和urllib2的区别" class="headerlink" title="4 urllib和urllib2的区别"></a>4 urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p>
<ol>
<li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li>
</ol>
<h2 id="5-Post和Get"><a href="#5-Post和Get" class="headerlink" title="5 Post和Get"></a>5 Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener">知乎回答</a></p>
<p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p>
<h2 id="6-Cookie和Session"><a href="#6-Cookie和Session" class="headerlink" title="6 Cookie和Session"></a>6 Cookie和Session</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Cookie</th>
<th style="text-align:left">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存位置</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">服务器端</td>
</tr>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td style="text-align:left">跟踪会话</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">不安全</td>
<td style="text-align:left">安全</td>
</tr>
</tbody>
</table>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<h2 id="7-apache和nginx的区别"><a href="#7-apache和nginx的区别" class="headerlink" title="7 apache和nginx的区别"></a>7 apache和nginx的区别</h2><p>nginx 相对 apache 的优点：</p>
<ul>
<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>
<li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li>rewrite ，比nginx 的rewrite 强大</li>
<li>模块超多，基本想到的都可以找到</li>
<li>少bug ，nginx 的bug 相对较多</li>
<li>超稳定</li>
</ul>
<h2 id="8-网站用户密码保存"><a href="#8-网站用户密码保存" class="headerlink" title="8 网站用户密码保存"></a>8 网站用户密码保存</h2><ol>
<li>明文保存</li>
<li>明文hash后保存,如md5</li>
<li>MD5+Salt方式,这个salt可以随机</li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h2 id="9-HTTP和HTTPS"><a href="#9-HTTP和HTTPS" class="headerlink" title="9 HTTP和HTTPS"></a>9 HTTP和HTTPS</h2><table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx 报告</td>
<td style="text-align:left">接收到请求，继续进程</td>
</tr>
<tr>
<td style="text-align:left">2xx 成功</td>
<td style="text-align:left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td style="text-align:left">3xx 重定向</td>
<td style="text-align:left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td style="text-align:left">4xx 客户端出错</td>
<td style="text-align:left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td style="text-align:left">5xx 服务器出错</td>
<td style="text-align:left">服务器无法完成显然有效的请求</td>
</tr>
</tbody>
</table>
<p>403: Forbidden<br>404: Not Found</p>
<p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p>
<h2 id="10-XSRF和XSS"><a href="#10-XSRF和XSS" class="headerlink" title="10 XSRF和XSS"></a>10 XSRF和XSS</h2><ul>
<li>CSRF(Cross-site request forgery)跨站请求伪造</li>
<li>XSS(Cross Site Scripting)跨站脚本攻击</li>
</ul>
<p>CSRF重点在请求,XSS重点在脚本</p>
<h2 id="12-RESTful架构-SOAP-RPC"><a href="#12-RESTful架构-SOAP-RPC" class="headerlink" title="12 RESTful架构(SOAP,RPC)"></a>12 RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<h2 id="15-CGI和WSGI"><a href="#15-CGI和WSGI" class="headerlink" title="15 CGI和WSGI"></a>15 CGI和WSGI</h2><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
<p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP-3333</a></p>
<h2 id="18-socket"><a href="#18-socket" class="headerlink" title="18 socket"></a>18 socket</h2><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<h2 id="19-浏览器缓存"><a href="#19-浏览器缓存" class="headerlink" title="19 浏览器缓存"></a>19 浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<h2 id="20-HTTP1-0和HTTP1-1"><a href="#20-HTTP1-0和HTTP1-1" class="headerlink" title="20 HTTP1.0和HTTP1.1"></a>20 HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="noopener">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<ol>
<li>请求头Host字段,一个服务器多个网站</li>
<li>长链接</li>
<li>文件断点续传</li>
<li>身份认证,状态管理,Cache缓存</li>
</ol>
<p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p>
<p>GET</p>
<p>GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。</p>
<p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p>
<p>HEAD</p>
<p>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p>
<p>POST</p>
<p>POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</p>
<p>PUT</p>
<p>PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p>
<p>DELETE</p>
<p>DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p>
<p>CONNECT</p>
<p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<p>OPTIONS</p>
<p>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p>
<p>TRACE</p>
<p>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</p>
<p>HTTP/1.1之后增加的方法</p>
<p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p>
<p>PATCH</p>
<p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p>
<p>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。<br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="1-列表复制问题"><a href="#1-列表复制问题" class="headerlink" title="1 列表复制问题"></a>1 列表复制问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1=[None,None]</span><br><span class="line">list2=list1*2 --&gt;[None,None,None,None]</span><br><span class="line">list3=[list1]*2 --&gt;[[None,None],[None,None]]</span><br></pre></td></tr></table></figure>
<h2 id="2-求列表第三大的那个值"><a href="#2-求列表第三大的那个值" class="headerlink" title="2 求列表第三大的那个值"></a>2 求列表第三大的那个值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">b = [random.randint(1,10000) for i in range(1000)]</span><br><span class="line">max1 = b[0]</span><br><span class="line">max2 = b[1]</span><br><span class="line">max3 = b[2]</span><br><span class="line">for k in b:</span><br><span class="line">    if k&gt;max1:</span><br><span class="line">        max1,max2,max3 = k,max1,max2</span><br><span class="line">    if k&gt;max3 and k&lt;max2:</span><br><span class="line">        max3 = k</span><br><span class="line">    if k&gt;max2 and k&lt;max1:</span><br><span class="line">        max3 = max2</span><br><span class="line">        max2 = k</span><br><span class="line">print(&apos;&#123;0&#125;,&#123;1&#125;,&#123;2&#125;&apos;.format(max1,max2,max3))</span><br></pre></td></tr></table></figure>
<h2 id="3-实现一个队列"><a href="#3-实现一个队列" class="headerlink" title="3 实现一个队列"></a>3 实现一个队列</h2><p><a href="https://www.cnblogs.com/chongyou/p/7099326.html" target="_blank" rel="noopener">参考博客园</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># 首先获取节点，包含next指针和该节点位置上元素的值</span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.next = None</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Queue(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.first = None</span><br><span class="line">        self.last = None</span><br><span class="line"></span><br><span class="line">    # 进队操作</span><br><span class="line">    def enter(self, n):</span><br><span class="line">        # 实例节点</span><br><span class="line">        n = Node(n)</span><br><span class="line">        # 进队之前先判断队列是否为空，即判断first是否为None</span><br><span class="line">        if self.first == None:</span><br><span class="line">            # 此时last==first==n</span><br><span class="line">            self.first = n</span><br><span class="line">            self.last = self.first</span><br><span class="line">        else:</span><br><span class="line">            # 将last的指针设置为n，值设置为n</span><br><span class="line">            self.last.next = n</span><br><span class="line">            self.last = n</span><br><span class="line"></span><br><span class="line">    # 出队</span><br><span class="line">    def quit(self):</span><br><span class="line">        if self.first == None:</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            tmp = self.first.val</span><br><span class="line">            self.first = self.first.next</span><br><span class="line">        return tmp</span><br><span class="line"></span><br><span class="line">    # 保存队列元素到列表</span><br><span class="line">    def allQuit(self):</span><br><span class="line">        Lists = []</span><br><span class="line">        while self.first != None:</span><br><span class="line">            Lists.append(self.first.val)</span><br><span class="line">            self.first = self.first.next</span><br><span class="line">        return Lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    q = Queue()</span><br><span class="line">    q.enter(1)</span><br><span class="line">    q.enter(2)</span><br><span class="line">    q.enter(3)</span><br><span class="line">    # print(q.quit())</span><br><span class="line">    # print(q.quit())</span><br><span class="line">    # print(q.quit())</span><br><span class="line">    # print(q.quit())</span><br><span class="line"></span><br><span class="line">    print(q.allQuit())</span><br></pre></td></tr></table></figure></p>
<h2 id="4-实现一个堆栈"><a href="#4-实现一个堆栈" class="headerlink" title="4 实现一个堆栈"></a>4 实现一个堆栈</h2><p><a href="https://www.cnblogs.com/chongyou/p/7099692.html" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Stack(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.top = None</span><br><span class="line"></span><br><span class="line">    # 获取栈顶的值</span><br><span class="line">    def peek(self):</span><br><span class="line">        if self.top != None:</span><br><span class="line">            return self.top.val</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">    # 入栈操作</span><br><span class="line">    def push(self, n):</span><br><span class="line">        n = Node(n)  # 实例化节点</span><br><span class="line">        n.next = self.top</span><br><span class="line">        self.top = n</span><br><span class="line">        return n.val</span><br><span class="line"></span><br><span class="line">    # 出栈操作</span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.top == None:</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            tmp = self.top.val</span><br><span class="line">            # return self.top.val</span><br><span class="line">            self.top = self.top.next  # 栈顶元素下移一位</span><br><span class="line">            return tmp</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    s = Stack()</span><br><span class="line">    # s.peek()</span><br><span class="line">    s.push(1)</span><br><span class="line">    print(s.peek())</span><br><span class="line">    s.push(2)</span><br><span class="line">    print(s.peek())</span><br><span class="line">    s.push(3)</span><br><span class="line">    print(s.peek())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.pop())</span><br></pre></td></tr></table></figure>
<h2 id="5-用Python实现一个单向链表"><a href="#5-用Python实现一个单向链表" class="headerlink" title="5 用Python实现一个单向链表"></a>5 用Python实现一个单向链表</h2><p><a href="https://blog.csdn.net/qq490691606/article/details/49945287" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;节点类&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.nex = None</span><br><span class="line"></span><br><span class="line">def __init__(self):</span><br><span class="line">    &quot;&quot;&quot;初始化链表&quot;&quot;&quot;</span><br><span class="line">    self.head = None</span><br><span class="line"></span><br><span class="line">def __len__(self):</span><br><span class="line">    pre = self.head</span><br><span class="line">    length = 0</span><br><span class="line">    while pre:</span><br><span class="line">        length += 1</span><br><span class="line">        pre = pre.nex</span><br><span class="line">    return length</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;追加节点&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def append(self, data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    1.head 为none :head--&gt;node</span><br><span class="line">    2.tail.nex--&gt;node</span><br><span class="line">    :param data:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    node = Node(data)</span><br><span class="line">    if self.head is None:</span><br><span class="line">        self.head = node</span><br><span class="line">    else:</span><br><span class="line">        pre = self.head</span><br><span class="line">        while pre.nex:</span><br><span class="line">            pre = pre.nex</span><br><span class="line">        pre.nex = node</span><br><span class="line"># 获取节点</span><br><span class="line">def get(self, index):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param index:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    index = index if index &gt;= 0 else len(self) + index</span><br><span class="line">    if len(self) &lt; index or index &lt; 0:</span><br><span class="line">        return None</span><br><span class="line">    pre = self.head</span><br><span class="line">    while index:</span><br><span class="line">        pre = pre.nex</span><br><span class="line">        index -= 1</span><br><span class="line">    return pre</span><br><span class="line">&quot;&quot;&quot;设置节点&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def set(self, index, data):</span><br><span class="line">    node = self.get(index)</span><br><span class="line">    if node:</span><br><span class="line">        node.data = data</span><br><span class="line">    return node</span><br><span class="line">&quot;&quot;&quot;插入节点&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def insert(self, index, data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    1.index 插入节点位置包括正负数</span><br><span class="line">    2.找到index-1--&gt;pre_node的节点</span><br><span class="line">    3.pre_node.next--&gt;node</span><br><span class="line">      node.next--&gt;pre_node.next.next</span><br><span class="line">    4.head</span><br><span class="line">    :param index:</span><br><span class="line">    :param data:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    node = Node(data)</span><br><span class="line">    if abs(index + 1) &gt; len(self):</span><br><span class="line">        return False</span><br><span class="line">    index = index if index &gt;= 0 else len(self) + index + 1</span><br><span class="line">    if index == 0:</span><br><span class="line">        node.nex = self.head</span><br><span class="line">        self.head = node</span><br><span class="line">    else:</span><br><span class="line">        pre = self.get(index - 1)</span><br><span class="line">        if pre:</span><br><span class="line">            nex = pre.nex</span><br><span class="line">            pre.nex = node</span><br><span class="line">            node.nex = nex</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    return node</span><br><span class="line">&quot;&quot;&quot;删除某个元素&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def delete(self, index):</span><br><span class="line">    f = index if index &gt; 0 else abs(index + 1)</span><br><span class="line">    if len(self) &lt;= f:</span><br><span class="line">        return False</span><br><span class="line">    pre = self.head</span><br><span class="line">    index = index if index &gt;= 0 else len(self) + index</span><br><span class="line">    prep = None</span><br><span class="line">    while index:</span><br><span class="line">        prep = pre</span><br><span class="line">        pre = pre.nex</span><br><span class="line">        index -= 1</span><br><span class="line">    if not prep:</span><br><span class="line">        self.head = pre.nex</span><br><span class="line">    else:</span><br><span class="line">        prep.nex = pre.nex</span><br><span class="line">    return pre.data</span><br><span class="line">&quot;&quot;&quot;反转链表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def __reversed__(self):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    1.pre--&gt;next 转变为 next--&gt;pre</span><br><span class="line">    2.pre 若是head 则把 pre.nex --&gt; None</span><br><span class="line">    3.tail--&gt;self.head</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def reverse(pre_node, node):</span><br><span class="line">        if pre_node is self.head:</span><br><span class="line">            pre_node.nex = None</span><br><span class="line">        if node:</span><br><span class="line">            next_node = node.nex</span><br><span class="line">            node.nex = pre_node</span><br><span class="line">            return reverse(node, next_node)</span><br><span class="line">        else:</span><br><span class="line">            self.head = pre_node</span><br><span class="line"></span><br><span class="line">    return reverse(self.head, self.head.nex)</span><br><span class="line">&quot;&quot;&quot;清空链表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def clear(self):</span><br><span class="line">    self.head = None</span><br></pre></td></tr></table></figure></p>
<h2 id="6-用Python实现一个双向链表"><a href="#6-用Python实现一个双向链表" class="headerlink" title="6 用Python实现一个双向链表"></a>6 用Python实现一个双向链表</h2><p><a href="https://blog.csdn.net/qq490691606/article/details/49948263" target="_blank" rel="noopener">参考</a><br>参考原文 代码省略</p>
<h2 id="7-台阶问题-斐波那契"><a href="#7-台阶问题-斐波那契" class="headerlink" title="7 台阶问题/斐波那契"></a>7 台阶问题/斐波那契</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>第二种记忆方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(i<span class="number">-1</span>) + fib(i<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p>第三种方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h2 id="8-变态台阶问题"><a href="#8-变态台阶问题" class="headerlink" title="8 变态台阶问题"></a>8 变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="9-去除列表中的重复元素"><a href="#9-去除列表中的重复元素" class="headerlink" title="9 去除列表中的重复元素"></a>9 去除列表中的重复元素</h2><p>用集合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(l))</span><br></pre></td></tr></table></figure>
<p>用字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure>
<p>用字典并保持顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = list(set(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure>
<p>列表推导式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">   <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> l2:</span><br><span class="line">       l2.append(i)</span><br></pre></td></tr></table></figure>
<p>sorted排序并且用列表推导式.</p>
<p>l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’]<br>[single.append(i) for i in sorted(l) if i not in single]<br>print single</p>
<h2 id="10-创建字典的方法"><a href="#10-创建字典的方法" class="headerlink" title="10 创建字典的方法"></a>10 创建字典的方法</h2><h3 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="1 直接创建"></a>1 直接创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'name'</span>:<span class="string">'earth'</span>, <span class="string">'port'</span>:<span class="string">'80'</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items=[(<span class="string">'name'</span>,<span class="string">'earth'</span>),(<span class="string">'port'</span>,<span class="string">'80'</span>)]</span><br><span class="line">dict2=dict(items)</span><br><span class="line">dict1=dict(([<span class="string">'name'</span>,<span class="string">'earth'</span>],[<span class="string">'port'</span>,<span class="string">'80'</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="3 fromkeys()方法"></a>3 fromkeys()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>),<span class="number">-1</span>)</span><br><span class="line">dict=&#123;<span class="string">'x'</span>:<span class="number">-1</span>,<span class="string">'y'</span>:<span class="number">-1</span>&#125;</span><br><span class="line">dict2=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>))</span><br><span class="line">dict2=&#123;<span class="string">'x'</span>:<span class="keyword">None</span>, <span class="string">'y'</span>:<span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-合并两个有序列表"><a href="#11-合并两个有序列表" class="headerlink" title="11 合并两个有序列表"></a>11 合并两个有序列表</h2><p>知乎远程面试要求编程</p>
<blockquote>
<p> 尾递归</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion_merge_sort2</span><span class="params">(l1, l2, tmp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(l1) == <span class="number">0</span> <span class="keyword">or</span> len(l2) == <span class="number">0</span>:</span><br><span class="line">        tmp.extend(l1)</span><br><span class="line">        tmp.extend(l2)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</span><br><span class="line">            tmp.append(l1[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l1[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(l2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l2[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_merge_sort2</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, [])</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 循环算法</p>
</blockquote>
<p>思路：</p>
<p>定义一个新的空列表</p>
<p>比较两个列表的首个元素</p>
<p>小的就插入到新列表里</p>
<p>把已经插入新列表的元素从旧列表删除</p>
<p>直到两个旧列表有一个为空</p>
<p>再把旧列表加到新列表后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def loop_merge_sort(l1, l2):</span><br><span class="line">    tmp = []</span><br><span class="line">    while len(l1) &gt; 0 and len(l2) &gt; 0:</span><br><span class="line">        if l1[0] &lt; l2[0]:</span><br><span class="line">            tmp.append(l1[0])</span><br><span class="line">            del l1[0]</span><br><span class="line">        else:</span><br><span class="line">            tmp.append(l2[0])</span><br><span class="line">            del l2[0]</span><br><span class="line">    tmp.extend(l1)</span><br><span class="line">    tmp.extend(l2)</span><br><span class="line">    return tmp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pop弹出</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sortedlist</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line">        <span class="keyword">if</span> a[<span class="number">0</span>] &gt;= b[<span class="number">0</span>]:</span><br><span class="line">            c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        c.append(a.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        c.append(b.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">print</span> merge_sortedlist(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="12-归并排序"><a href="#12-归并排序" class="headerlink" title="12 归并排序"></a>12 归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def merge(a, b):</span><br><span class="line">    c = []</span><br><span class="line">    h = j = 0</span><br><span class="line">    # 依次便利，拿到兩個數組更小的元素，</span><br><span class="line">    while j &lt; len(a) and h &lt; len(b):</span><br><span class="line">        # 如果0索引位置的元素a更小，添加a[0]到c，再將a[1]與b[0]比較，依次類推，剩余最后的元素就是两个数组的最大值</span><br><span class="line">        if a[j] &lt; b[h]:</span><br><span class="line">            c.append(a[j])</span><br><span class="line">            j += 1</span><br><span class="line">        else:</span><br><span class="line">            c.append(b[h])</span><br><span class="line">            h += 1</span><br><span class="line"></span><br><span class="line">    if j == len(a):</span><br><span class="line">        for i in b[h:]:</span><br><span class="line">            c.append(i)</span><br><span class="line">    else:</span><br><span class="line">        for i in a[j:]:</span><br><span class="line">            c.append(i)</span><br><span class="line"></span><br><span class="line">    return c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def merge_sort(lists):</span><br><span class="line">    if len(lists) &lt;= 1:</span><br><span class="line">        return lists</span><br><span class="line">    middle = len(lists)//2</span><br><span class="line">    left = merge_sort(lists[:middle])</span><br><span class="line">    right = merge_sort(lists[middle:])</span><br><span class="line">    return merge(left, right)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = [4, 7, 8, 3, 5, 9,10]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure>
<h2 id="13-质数和日期问题"><a href="#13-质数和日期问题" class="headerlink" title="13 质数和日期问题"></a>13 质数和日期问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class PrimeNumbers(object):</span><br><span class="line">    def __init__(self, start, end):</span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    def isPrimeNumber(self, k):</span><br><span class="line">        if k &lt; 2:</span><br><span class="line">            return False</span><br><span class="line">        for i in range(2, k):</span><br><span class="line">            if k % i == 0:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        for k in range(self.start, self.end + 1):</span><br><span class="line">            if self.isPrimeNumber(k):</span><br><span class="line">                yield k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#print(isinstance(PrimeNumbers(1,100)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = PrimeNumbers(1, 100)</span><br><span class="line">    f = a.__iter__()</span><br><span class="line">    L = []</span><br><span class="line">    for i in f:</span><br><span class="line">        L.append(i)</span><br><span class="line">    print(L)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 写一个函数，计算给定日期是该年的第几天和周数</span><br><span class="line">def count(year,month,day):</span><br><span class="line">    count=0</span><br><span class="line">    if (year%4==0 and year%100!=0) or year%400==0:</span><br><span class="line">        print(&apos;%d年是闰年，2月份有29天！&apos;%year)</span><br><span class="line">        list1=[31,29,31,30,31,30,31,31,30,31,30,31]</span><br><span class="line">        for i in range(month-1):</span><br><span class="line">            count=count+list1[i]</span><br><span class="line">        return count+</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;%d年是平年，2月份有29天！&apos; % year)</span><br><span class="line">        li2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</span><br><span class="line">        for i in range(month-1):</span><br><span class="line">            count +=li2[i]</span><br><span class="line">        return count+day</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    year = int(input(&apos;请输入年份：&apos;))</span><br><span class="line">    month = int(input(&apos;请输入月份：&apos;))</span><br><span class="line">    day = int(input(&apos;请输入日期：&apos;))</span><br><span class="line">    count = count(year,month,day)</span><br><span class="line">    print(&apos;%d年%d月%d日是今年的第%d天！&apos;%(year,month,day,count))</span><br></pre></td></tr></table></figure>
<h2 id="14-二分查找"><a href="#14-二分查找" class="headerlink" title="14 二分查找"></a>14 二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list,item)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(list)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low&lt;=high:</span><br><span class="line">        mid = (low+high)/<span class="number">2</span></span><br><span class="line">        guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess&gt;item:</span><br><span class="line">            high = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> guess&lt;item:</span><br><span class="line">            low = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">mylist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">print</span> binary_search(mylist,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>参考: <a href="http://blog.csdn.net/u013205877/article/details/76411718" target="_blank" rel="noopener">http://blog.csdn.net/u013205877/article/details/76411718</a></p>
<h2 id="15-打印文件夹"><a href="#15-打印文件夹" class="headerlink" title="15 打印文件夹"></a>15 打印文件夹</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def print_directory_contents(sPath):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    这个函数接受文件夹的名称作为输入参数，</span><br><span class="line">    返回该文件夹中文件的路径，</span><br><span class="line">    以及其包含文件夹中文件的路径。</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import os                                       </span><br><span class="line">    for sChild in os.listdir(sPath):                </span><br><span class="line">        sChildPath = os.path.join(sPath,sChild)</span><br><span class="line">        if os.path.isdir(sChildPath):</span><br><span class="line">            print_directory_contents(sChildPath)</span><br><span class="line">        else:</span><br><span class="line">            print sChildPath</span><br></pre></td></tr></table></figure>
<h2 id="16-找零问题"><a href="#16-找零问题" class="headerlink" title="16 找零问题"></a>16 找零问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#values是硬币的面值values = [ 25, 21, 10, 5, 1]</span></span><br><span class="line"><span class="comment">#valuesCounts   钱币对应的种类数</span></span><br><span class="line"><span class="comment">#money  找出来的总钱数</span></span><br><span class="line"><span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(values,valuesCounts,money,coinsUsed)</span>:</span></span><br><span class="line">    <span class="comment">#遍历出从1到money所有的钱数可能</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>,money+<span class="number">1</span>):</span><br><span class="line">        minCoins = cents</span><br><span class="line">        <span class="comment">#把所有的硬币面值遍历出来和钱数做对比</span></span><br><span class="line">        <span class="keyword">for</span> kind <span class="keyword">in</span> range(<span class="number">0</span>,valuesCounts):</span><br><span class="line">            <span class="keyword">if</span> (values[kind] &lt;= cents):</span><br><span class="line">                temp = coinsUsed[cents - values[kind]] +<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; minCoins):</span><br><span class="line">                    minCoins = temp</span><br><span class="line">        coinsUsed[cents] = minCoins</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;'</span>.format(cents, coinsUsed[cents]))</span><br></pre></td></tr></table></figure>
<p>思路: <a href="http://blog.csdn.net/wdxin1322/article/details/9501163" target="_blank" rel="noopener">http://blog.csdn.net/wdxin1322/article/details/9501163</a></p>
<p>方法: <a href="http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html" target="_blank" rel="noopener">http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html</a></p>
<h2 id="17-二叉树节点"><a href="#17-二叉树节点" class="headerlink" title="17 二叉树节点"></a>17 二叉树节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, left=None, right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">tree = Node(<span class="number">1</span>, Node(<span class="number">3</span>, Node(<span class="number">7</span>, Node(<span class="number">0</span>)), Node(<span class="number">6</span>)), Node(<span class="number">2</span>, Node(<span class="number">5</span>), Node(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="17-前中后序遍历"><a href="#17-前中后序遍历" class="headerlink" title="17 前中后序遍历"></a>17 前中后序遍历</h2><p>深度遍历改变顺序就OK了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#二叉树的遍历</span></span><br><span class="line"><span class="comment">#简单的二叉树节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value,left,right)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="comment">#中序遍历:遍历左子树,访问当前节点,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid_travelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        mid_travelsal(root.left)</span><br><span class="line">    <span class="comment">#访问当前节点</span></span><br><span class="line">    print(root.value)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        mid_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#前序遍历:访问当前节点,遍历左子树,遍历右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_travelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (root.value)</span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pre_travelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pre_travelsal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#后续遍历:遍历左子树,遍历右子树,访问当前节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_trvelsal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        post_trvelsal(root.left)</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        post_trvelsal(root.right)</span><br><span class="line">    <span class="keyword">print</span> (root.value)</span><br></pre></td></tr></table></figure>
<h2 id="18-求最大树深"><a href="#18-求最大树深" class="headerlink" title="18 求最大树深"></a>18 求最大树深</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="19-求两棵树是否相同"><a href="#19-求两棵树是否相同" class="headerlink" title="19 求两棵树是否相同"></a>19 求两棵树是否相同</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left,q.left) <span class="keyword">and</span> isSameTree(p.right,q.right)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="20-前序中序求后序"><a href="#20-前序中序求后序" class="headerlink" title="20 前序中序求后序"></a>20 前序中序求后序</h2><p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502" target="_blank" rel="noopener">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild</span><span class="params">(pre, center)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = Node(pre[<span class="number">0</span>])</span><br><span class="line">    index = center.index(pre[<span class="number">0</span>])</span><br><span class="line">    cur.left = rebuild(pre[<span class="number">1</span>:index + <span class="number">1</span>], center[:index])</span><br><span class="line">    cur.right = rebuild(pre[index + <span class="number">1</span>:], center[index + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br></pre></td></tr></table></figure>
<h2 id="21-广度遍历和深度遍历二叉树"><a href="#21-广度遍历和深度遍历二叉树" class="headerlink" title="21 广度遍历和深度遍历二叉树"></a>21 广度遍历和深度遍历二叉树</h2><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p>
<h2 id="22-快排"><a href="#22-快排" class="headerlink" title="22 快排"></a>22 快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(list)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpivot = list[<span class="number">0</span>]</span><br><span class="line">        lessbeforemidpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i&lt;=midpivot]</span><br><span class="line">        biggerafterpivot = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; midpivot]</span><br><span class="line">        finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot)</span><br><span class="line">        <span class="keyword">return</span> finallylist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lambda函数实现</span></span><br><span class="line">quicksort=<span class="keyword">lambda</span> data:data <span class="keyword">if</span> len(data)&lt;<span class="number">2</span> <span class="keyword">else</span> quicksort([item <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="number">1</span>:] <span class="keyword">if</span> item&lt;=data[<span class="number">0</span>]])+[data[<span class="number">0</span>]]+quicksort([item <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="number">1</span>:] <span class="keyword">if</span> item&gt;data[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> quicksort([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 更多排序问题可见：<a href="http://blog.csdn.net/mrlevo520/article/details/77829204" target="_blank" rel="noopener">数据结构与算法-排序篇-Python描述</a></p>
</blockquote>
<h2 id="23-层次遍历"><a href="#23-层次遍历" class="headerlink" title="23 层次遍历"></a>23 层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span><span class="params">(root)</span>:</span></span><br><span class="line">    row = [root]</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(row)</span><br><span class="line">        row = [kid <span class="keyword">for</span> item <span class="keyword">in</span> row <span class="keyword">for</span> kid <span class="keyword">in</span> (item.left, item.right) <span class="keyword">if</span> kid]</span><br></pre></td></tr></table></figure>
<h2 id="24-深度遍历"><a href="#24-深度遍历" class="headerlink" title="24 深度遍历"></a>24 深度遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lookup(tree)</span><br><span class="line">    deep(tree)</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/10/hello-world/" rel="prev" title="Hello World">
                Hello World <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jeese zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zhwl934008411" title="GitHub &rarr; https://github.com/zhwl934008411" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:zhwl934008411@gmail.com" title="E-Mail &rarr; mailto:zhwl934008411@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python语言特性"><span class="nav-number">1.</span> <span class="nav-text">Python语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-对Python的理解-对比其他语言"><span class="nav-number">1.1.</span> <span class="nav-text">1 对Python的理解(对比其他语言)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#补充"><span class="nav-number">1.1.1.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-什么是Python的命名空间"><span class="nav-number">1.2.</span> <span class="nav-text">2 什么是Python的命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Python中的pass语句"><span class="nav-number">1.3.</span> <span class="nav-text">3 Python中的pass语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Python异常处理的用法和作用"><span class="nav-number">1.4.</span> <span class="nav-text">4　Python异常处理的用法和作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Python的函数参数传递"><span class="nav-number">1.5.</span> <span class="nav-text">5 Python的函数参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-函数的参数用法和注意事项"><span class="nav-number">1.6.</span> <span class="nav-text">6 函数的参数用法和注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-可变对象和不可变对象"><span class="nav-number">1.7.</span> <span class="nav-text">7 可变对象和不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-def是运行时执行语句-并且是赋值语句"><span class="nav-number">1.8.</span> <span class="nav-text">8 def是运行时执行语句,并且是赋值语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-Python是否能以可变对象做函数默认参数"><span class="nav-number">1.9.</span> <span class="nav-text">9 Python是否能以可变对象做函数默认参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-企图在函数中修改全局变量-没有使用global-而创建了本地变量"><span class="nav-number">1.10.</span> <span class="nav-text">10 企图在函数中修改全局变量,没有使用global,而创建了本地变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-对象的dir属性和dict属性"><span class="nav-number">1.11.</span> <span class="nav-text">11 对象的dir属性和dict属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-staticmethod和-classmethod"><span class="nav-number">1.12.</span> <span class="nav-text">12 @staticmethod和@classmethod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-使用property创建可管理的对象属性"><span class="nav-number">1.13.</span> <span class="nav-text">13 使用property创建可管理的对象属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-类属性和实例属性"><span class="nav-number">1.14.</span> <span class="nav-text">14 类属性和实例属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-Python自省"><span class="nav-number">1.15.</span> <span class="nav-text">15 Python自省</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-字典解析、列表解析、集合解析"><span class="nav-number">1.16.</span> <span class="nav-text">16 字典解析、列表解析、集合解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#补充1-如何为元组的每个元素命名-提高程序可读性"><span class="nav-number">1.16.0.1.</span> <span class="nav-text">补充1 如何为元组的每个元素命名,提高程序可读性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充2-如何统计序列中元素的出现频度"><span class="nav-number">1.16.0.2.</span> <span class="nav-text">补充2 如何统计序列中元素的出现频度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充3-如何快速找到多个字典中的公共键-key"><span class="nav-number">1.16.0.3.</span> <span class="nav-text">补充3 如何快速找到多个字典中的公共键(key)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充4-创建有序的字典"><span class="nav-number">1.16.0.4.</span> <span class="nav-text">补充4 创建有序的字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充5-元组和列表的同异"><span class="nav-number">1.16.0.5.</span> <span class="nav-text">补充5 元组和列表的同异</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-Python中单下划线和双下划线"><span class="nav-number">1.17.</span> <span class="nav-text">17 Python中单下划线和双下划线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-字符串格式化-和-format"><span class="nav-number">1.18.</span> <span class="nav-text">18 字符串格式化:%和.format</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-正则表达式相关知识及字符串操作"><span class="nav-number">1.19.</span> <span class="nav-text">19 正则表达式相关知识及字符串操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-迭代器和生成器"><span class="nav-number">1.20.</span> <span class="nav-text">20 迭代器和生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-args-and-kwargs"><span class="nav-number">1.21.</span> <span class="nav-text">21 *args and **kwargs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-装饰器"><span class="nav-number">1.22.</span> <span class="nav-text">22 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器用做日志记录"><span class="nav-number">1.22.0.1.</span> <span class="nav-text">装饰器用做日志记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何定义带参数的装饰器"><span class="nav-number">1.22.0.2.</span> <span class="nav-text">如何定义带参数的装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器用做执行时间统计"><span class="nav-number">1.22.0.3.</span> <span class="nav-text">装饰器用做执行时间统计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器用做缓存"><span class="nav-number">1.22.0.4.</span> <span class="nav-text">装饰器用做缓存</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#23-Python中重载"><span class="nav-number">1.23.</span> <span class="nav-text">23 Python中重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-new-和-init-的区别"><span class="nav-number">1.24.</span> <span class="nav-text">24 __new__和__init__的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-单例模式"><span class="nav-number">1.25.</span> <span class="nav-text">25 单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-使用-new-方法"><span class="nav-number">1.25.1.</span> <span class="nav-text">1 使用__new__方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-共享属性"><span class="nav-number">1.25.2.</span> <span class="nav-text">2 共享属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-装饰器版本"><span class="nav-number">1.25.3.</span> <span class="nav-text">3 装饰器版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-import方法"><span class="nav-number">1.25.4.</span> <span class="nav-text">4 import方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-Python中的作用域"><span class="nav-number">1.26.</span> <span class="nav-text">26 Python中的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-GIL线程全局锁"><span class="nav-number">1.27.</span> <span class="nav-text">27 GIL线程全局锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-协程"><span class="nav-number">1.28.</span> <span class="nav-text">28 协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考廖雪峰"><span class="nav-number">1.28.1.</span> <span class="nav-text">参考廖雪峰</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-闭包"><span class="nav-number">1.29.</span> <span class="nav-text">29 闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-lambda函数"><span class="nav-number">1.30.</span> <span class="nav-text">30 lambda函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-Python函数式编程"><span class="nav-number">1.31.</span> <span class="nav-text">31 Python函数式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-Python里的拷贝"><span class="nav-number">1.32.</span> <span class="nav-text">32 Python里的拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-Python是如何进行内存管理的"><span class="nav-number">1.33.</span> <span class="nav-text">33 Python是如何进行内存管理的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-Python的List和Dict的实现原理"><span class="nav-number">1.34.</span> <span class="nav-text">34 Python的List和Dict的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-Python的is和"><span class="nav-number">1.35.</span> <span class="nav-text">35 Python的is和==</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-read-readline和readlines"><span class="nav-number">1.36.</span> <span class="nav-text">36 read,readline和readlines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-Python2和3的区别"><span class="nav-number">1.37.</span> <span class="nav-text">37 Python2和3的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：Python的编码问题"><span class="nav-number">1.37.0.1.</span> <span class="nav-text">补充：Python的编码问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">2.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-事务"><span class="nav-number">2.1.</span> <span class="nav-text">1 事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-数据库索引"><span class="nav-number">2.2.</span> <span class="nav-text">2 数据库索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis原理"><span class="nav-number">2.3.</span> <span class="nav-text">3 Redis原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis是什么？"><span class="nav-number">2.3.1.</span> <span class="nav-text">Redis是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis数据库"><span class="nav-number">2.3.2.</span> <span class="nav-text">Redis数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis缺点"><span class="nav-number">2.3.3.</span> <span class="nav-text">Redis缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-MyISAM和InnoDB"><span class="nav-number">2.4.</span> <span class="nav-text">4 MyISAM和InnoDB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络"><span class="nav-number">3.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-三次握手"><span class="nav-number">3.1.</span> <span class="nav-text">1 三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-四次挥手"><span class="nav-number">3.2.</span> <span class="nav-text">2 四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ARP协议"><span class="nav-number">3.3.</span> <span class="nav-text">3 ARP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-urllib和urllib2的区别"><span class="nav-number">3.4.</span> <span class="nav-text">4 urllib和urllib2的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Post和Get"><span class="nav-number">3.5.</span> <span class="nav-text">5 Post和Get</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Cookie和Session"><span class="nav-number">3.6.</span> <span class="nav-text">6 Cookie和Session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-apache和nginx的区别"><span class="nav-number">3.7.</span> <span class="nav-text">7 apache和nginx的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-网站用户密码保存"><span class="nav-number">3.8.</span> <span class="nav-text">8 网站用户密码保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-HTTP和HTTPS"><span class="nav-number">3.9.</span> <span class="nav-text">9 HTTP和HTTPS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-XSRF和XSS"><span class="nav-number">3.10.</span> <span class="nav-text">10 XSRF和XSS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-RESTful架构-SOAP-RPC"><span class="nav-number">3.11.</span> <span class="nav-text">12 RESTful架构(SOAP,RPC)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-CGI和WSGI"><span class="nav-number">3.12.</span> <span class="nav-text">15 CGI和WSGI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-socket"><span class="nav-number">3.13.</span> <span class="nav-text">18 socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-浏览器缓存"><span class="nav-number">3.14.</span> <span class="nav-text">19 浏览器缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-HTTP1-0和HTTP1-1"><span class="nav-number">3.15.</span> <span class="nav-text">20 HTTP1.0和HTTP1.1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编程题"><span class="nav-number">4.</span> <span class="nav-text">编程题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-列表复制问题"><span class="nav-number">4.1.</span> <span class="nav-text">1 列表复制问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-求列表第三大的那个值"><span class="nav-number">4.2.</span> <span class="nav-text">2 求列表第三大的那个值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-实现一个队列"><span class="nav-number">4.3.</span> <span class="nav-text">3 实现一个队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-实现一个堆栈"><span class="nav-number">4.4.</span> <span class="nav-text">4 实现一个堆栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-用Python实现一个单向链表"><span class="nav-number">4.5.</span> <span class="nav-text">5 用Python实现一个单向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-用Python实现一个双向链表"><span class="nav-number">4.6.</span> <span class="nav-text">6 用Python实现一个双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-台阶问题-斐波那契"><span class="nav-number">4.7.</span> <span class="nav-text">7 台阶问题/斐波那契</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-变态台阶问题"><span class="nav-number">4.8.</span> <span class="nav-text">8 变态台阶问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-去除列表中的重复元素"><span class="nav-number">4.9.</span> <span class="nav-text">9 去除列表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-创建字典的方法"><span class="nav-number">4.10.</span> <span class="nav-text">10 创建字典的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-直接创建"><span class="nav-number">4.10.1.</span> <span class="nav-text">1 直接创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-工厂方法"><span class="nav-number">4.10.2.</span> <span class="nav-text">2 工厂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-fromkeys-方法"><span class="nav-number">4.10.3.</span> <span class="nav-text">3 fromkeys()方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-合并两个有序列表"><span class="nav-number">4.11.</span> <span class="nav-text">11 合并两个有序列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-归并排序"><span class="nav-number">4.12.</span> <span class="nav-text">12 归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-质数和日期问题"><span class="nav-number">4.13.</span> <span class="nav-text">13 质数和日期问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-二分查找"><span class="nav-number">4.14.</span> <span class="nav-text">14 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-打印文件夹"><span class="nav-number">4.15.</span> <span class="nav-text">15 打印文件夹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-找零问题"><span class="nav-number">4.16.</span> <span class="nav-text">16 找零问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-二叉树节点"><span class="nav-number">4.17.</span> <span class="nav-text">17 二叉树节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-前中后序遍历"><span class="nav-number">4.18.</span> <span class="nav-text">17 前中后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-求最大树深"><span class="nav-number">4.19.</span> <span class="nav-text">18 求最大树深</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-求两棵树是否相同"><span class="nav-number">4.20.</span> <span class="nav-text">19 求两棵树是否相同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-前序中序求后序"><span class="nav-number">4.21.</span> <span class="nav-text">20 前序中序求后序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-广度遍历和深度遍历二叉树"><span class="nav-number">4.22.</span> <span class="nav-text">21 广度遍历和深度遍历二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-快排"><span class="nav-number">4.23.</span> <span class="nav-text">22 快排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-层次遍历"><span class="nav-number">4.24.</span> <span class="nav-text">23 层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-深度遍历"><span class="nav-number">4.25.</span> <span class="nav-text">24 深度遍历</span></a></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeese zhao</span>

  

  
</div>


  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  

  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  





  





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
